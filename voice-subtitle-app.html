<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Speech Subtitles (OBS-ready)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            font-family: 'Noto Sans', 'Noto Sans JP', Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 20px;
        }

        .subtitle-container {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px 20px;
            margin-bottom: 10px;
            max-width: 80%;
            align-self: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .subtitle-jp {
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            line-height: 1.4;
        }

        .subtitle-en {
            color: #ffff99;
            font-size: 20px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            line-height: 1.4;
            font-style: italic;
        }

        /* interimï¼ˆé€”ä¸­çµæœï¼‰ç”¨ï¼šè–„ã„ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç¿»è¨³æ  */
        .preview-container {
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .preview-container .subtitle-jp {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 6px;
            opacity: 0.75;
        }

        .preview-container .subtitle-en {
            font-size: 16px;
            opacity: 0.75;
        }

        .preview-translation-indicator {
            color: rgba(255, 200, 120, 0.85);
            font-size: 11px;
            text-align: center;
            margin-bottom: 6px;
        }

        .final-container.hidden {
            display: none;
        }

        .range-value {
            color: white;
            width: 3.5em;
            text-align: right;
            display: inline-block;
        }

        .controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 250px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .stop-button {
            background: #f44336;
        }

        .stop-button:hover {
            background: #da190b;
        }

        label {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        select, input[type="range"], input[type="text"] {
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        input[type="text"] {
            width: 100%;
        }

        .mode-label {
            color: #90EE90;
            font-weight: bold;
        }

        .small-button {
            padding: 5px 10px;
            font-size: 12px;
        }

        .refresh-button {
            margin-left: 10px;
        }

        .compact-gap {
            gap: 6px;
        }

        .hidden {
            display: none;
        }

        .api-button {
            background: #2196F3;
        }

        .api-button:hover {
            background: #1976D2;
        }

        .translation-indicator {
            color: #FFA500;
            font-size: 12px;
            text-align: center;
            margin-bottom: 6px;
        }

        .confidence-indicator {
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .confidence-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #44ff44);
            transition: width 0.3s ease;
        }

        /* ãƒã‚¤ã‚¯å…¥åŠ›ãƒ¬ãƒ™ãƒ«ãƒ¡ãƒ¼ã‚¿ãƒ¼ */
        .level-meter {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .level-meter-track {
            flex: 1;
            height: 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.12);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .level-meter-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #44ff44, #ffaa00, #ff4444);
            transform-origin: left;
            transition: width 0.06s linear;
        }

        .level-meter-text {
            width: 4.5em;
            text-align: right;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.85);
            font-variant-numeric: tabular-nums;
        }

        .status {
            color: #90EE90;
            font-size: 12px;
            margin-top: 5px;
        }

        .hide-controls .controls {
            display: none;
        }

        .toggle-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .interim {
            opacity: 0.7;
            font-style: italic;
        }

        .final {
            opacity: 1;
            font-style: normal;
        }

        @media (max-width: 768px) {
            .subtitle-jp {
                font-size: 18px;
            }
            
            .subtitle-en {
                font-size: 16px;
            }
            
            .controls {
                font-size: 12px;
                min-width: 200px;
            }
        }

        /* è¡¨ç¤ºç¯„å›²ã‚¬ã‚¤ãƒ‰ */
        .display-area-guide {
            position: fixed;
            bottom: 10%;
            left: 10%;
            right: 10%;
            height: 200px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            pointer-events: none;
            z-index: 1;
            background: rgba(255, 255, 255, 0.02);
            display: none;
        }

        .display-area-guide.show {
            display: block;
        }

        .guide-label {
            position: absolute;
            top: -25px;
            left: 0;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            font-weight: bold;
        }

        .recording-indicator {
            position: fixed;
            top: 15px;
            right: 60px;
            background: rgba(255, 0, 0, 0.1);
            border: 2px solid #ff4444;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <!-- Recording indicator -->
    <div class="recording-indicator" id="recordingIndicator"></div>
    
    <!-- Display area guide -->
    <div class="display-area-guide" id="displayGuide">
        <div class="guide-label">Subtitle area</div>
    </div>

    <div class="container">
        <div class="subtitle-container hidden" id="subtitleContainer">
            <!-- interim: preview frame (separate from final) -->
            <div class="preview-container hidden" id="previewContainer">
                <div class="preview-translation-indicator hidden" id="previewTranslationIndicator">Preview translating...</div>
                <div class="subtitle-jp" id="previewJp"></div>
                <div class="subtitle-en" id="previewEn"></div>
            </div>

            <!-- final: committed subtitles -->
            <div class="final-container hidden" id="finalContainer">
                <div class="translation-indicator hidden" id="translationIndicator">Translating...</div>
                <div class="subtitle-jp" id="subtitleJp"></div>
                <div class="subtitle-en" id="subtitleEn"></div>
                <div class="confidence-indicator">
                    <div class="confidence-bar" id="confidenceBar"></div>
                </div>
            </div>
        </div>
    </div>

    <button class="toggle-controls" onclick="toggleControls()">Settings</button>

    <div class="controls" id="controls">
        <div class="control-row">
            <span class="mode-label">ğŸ¤ Speech recognition</span>
            <button id="startButton" class="small-button" onclick="startRecognition()">Start</button>
            <button id="stopButton" class="small-button stop-button" onclick="stopRecognition()" disabled>Stop</button>
        </div>
        
        <div class="control-row">
            <label for="microphoneSelect">Microphone:</label>
            <select id="microphoneSelect">
                <option value="default">Default microphone</option>
            </select>
            <button onclick="refreshMicrophones()" class="small-button refresh-button">ğŸ”„</button>
        </div>

        <div class="control-row">
            <label for="micLevelFill">Input level:</label>
            <div class="level-meter" aria-label="Microphone input level">
                <div class="level-meter-track">
                    <div class="level-meter-fill" id="micLevelFill"></div>
                </div>
                <div class="level-meter-text" id="micLevelText">0%</div>
            </div>
        </div>

        <div class="control-row compact-gap">
            <label for="apiKeyInput">Translation API key:</label>
            <input type="text" id="apiKeyInput" placeholder="Google Translate API key (optional)">
            <button class="small-button api-button" onclick="testApiKey()">Test</button>
        </div>

        <div class="control-row">
            <label for="targetLanguageSelect">Translate to:</label>
            <select id="targetLanguageSelect">
                <option value="en">English</option>
                <option value="ja">Japanese</option>
                <option value="ko">Korean</option>
                <option value="zh">Chinese</option>
                <option value="es">Spanish</option>
                <option value="fr">French</option>
                <option value="de">German</option>
            </select>
        </div>

        <div class="control-row">
            <label for="languageSelect">Recognition language:</label>
            <select id="languageSelect">
                <option value="ja-JP">Japanese</option>
                <option value="en-US">English</option>
                <option value="ko-KR">Korean</option>
                <option value="zh-CN">Chinese (Simplified)</option>
            </select>
        </div>

        <div class="control-row">
            <label>
                <input type="checkbox" id="showJapanese" checked> Japanese subtitles
            </label>
        </div>

        <div class="control-row">
            <label>
                <input type="checkbox" id="showEnglish" checked> English subtitles
            </label>
        </div>

        <div class="control-row">
            <label>
                <input type="checkbox" id="autoTranslate" checked> Auto-translate
            </label>
        </div>

        <div class="control-row">
            <label for="fontSizeRange">Font size:</label>
            <input type="range" id="fontSizeRange" min="14" max="36" value="24">
        </div>

        <div class="control-row">
            <label for="maxDurationRange">Display duration (sec):</label>
            <input type="range" id="maxDurationRange" min="3" max="15" value="8">
        </div>

        <div class="control-row">
            <label for="previewDebounceRange">Preview debounce (ms):</label>
            <input type="range" id="previewDebounceRange" min="100" max="1000" step="50" value="350">
            <span id="previewDebounceValue" class="range-value">350</span>
        </div>

        <div class="control-row">
            <label for="previewDurationRange">Preview display (sec):</label>
            <input type="range" id="previewDurationRange" min="1" max="10" value="3">
            <span id="previewDurationValue" class="range-value">3</span>
        </div>

        <div class="control-row">
            <label>
                <input type="checkbox" id="continuousMode" checked> Continuous recognition
            </label>
        </div>
        <div class="control-row">
            <label>
                <input type="checkbox" id="showDisplayGuide"> Show display guide
            </label>
        </div>
        <div class="status" id="status">Idle...</div>
    </div>

    <script>
        let recognition;
        let isRecognizing = false;
        let recognitionIsActive = false; // SpeechRecognitionãŒå®Ÿè¡Œä¸­ã‹ï¼ˆonstartã€œonendï¼‰
        let recognitionStartPending = false; // start() å‘¼ã³å‡ºã—ç›´å¾Œã€œonstartã¾ã§
        let lastSpeechTime = 0;
        let hideTimeout;
        let currentTranscript = '';
        let finalTranscript = '';
        let mediaStream = null;
        let currentMicDeviceId = null;
        let micStreamPromise = null;
        let availableMicrophones = [];
        let autoStarted = false;

        // ãƒã‚¤ã‚¯æ¨©é™ã®ã€Œã“ã®ãƒšãƒ¼ã‚¸å†…ã§ã®å†è¦æ±‚ã€ã‚’é¿ã‘ã‚‹ãŸã‚ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        const MIC_PERMISSION_CACHE_KEY = 'micPermissionGranted';
        const MIC_SELECTED_DEVICE_ID_KEY = 'selectedMicDeviceId';
        let micEverGrantedThisSession = false;

        let recognitionRestartTimer = null;
        let recognitionRestartDelayMs = 250;

        // ç¿»è¨³ï¼ˆGoogle Translate APIã¯ä»»æ„ï¼‰
        let translationRequestSeq = 0;

        // interimï¼ˆé€”ä¸­çµæœï¼‰ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç¿»è¨³ï¼ˆåˆ¥æ ï¼‰
        let previewTranslationSeq = 0;
        let previewDebounceTimer = null;
        let previewDebounceMs = 350; // adjustable

        // preview è¡¨ç¤ºæŒç¶šæ™‚é–“ï¼ˆç§’ï¼‰
        let previewDisplaySec = 3;
        let previewHideTimer = null;

        // finalï¼ˆç¢ºå®šï¼‰ã‚’é †åºä¿è¨¼ã§ç¿»è¨³ã™ã‚‹ã‚­ãƒ¥ãƒ¼
        let finalTranslateQueue = [];
        let finalQueueProcessing = false;
        let finalQueueSessionId = 0; // stop/start ã§å¢—ã‚„ã—ã¦å¤ã„å‡¦ç†ã‚’ç„¡åŠ¹åŒ–

        // è¡¨ç¤ºã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹å¤‰æ›´æ™‚ã®å†æç”»ç”¨ï¼‰
        const lastPreview = { jp: '', en: '', confidence: 0.5 };
        const lastFinal = { jp: '', en: '', confidence: 0.5 };

        // ãƒã‚¤ã‚¯ã®keep-aliveï¼ˆç„¡éŸ³æ”¾ç½®ã§ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒè½ã¡ã‚‹ç’°å¢ƒå‘ã‘ï¼‰
        let audioContext = null;
        let keepAliveSourceNode = null;
        let keepAliveGainNode = null;
        let micWatchdogTimer = null;
        let micRecoveryInProgress = false;
        let micRecoveryDelayMs = 1000;

        // èƒŒæ™¯ã§ getUserMedia ã‚’å‘¼ã¶ã¨ã€ç’°å¢ƒã«ã‚ˆã£ã¦ã¯å®šæœŸçš„ã«è¨±å¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒå‡ºã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚
        // ãã®ãŸã‚ã€Œè‡ªå‹•å¾©æ—§ã€ã¯è¡Œã‚ãšã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œï¼ˆStartï¼‰ã§ã®ã¿å†æ¥ç¶šã™ã‚‹ã€‚
        let micStreamEndedNotifiedAt = 0;

        // å…¥åŠ›ãƒ¬ãƒ™ãƒ«ãƒ¡ãƒ¼ã‚¿ãƒ¼
        let micLevelSourceNode = null;
        let micLevelAnalyserNode = null;
        let micLevelData = null;
        let micLevelRafId = null;
        let micLevelSmoothed = 0;
        
        // å­¦ç¿’æ©Ÿèƒ½ç”¨ã®å¤‰æ•°
        let userVocabulary = new Map(); // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èªå½™ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
        let speechPatterns = new Map(); // éŸ³å£°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å­¦ç¿’
        let translationHistory = []; // ç¿»è¨³å±¥æ­´
        let recognitionAccuracy = new Map(); // èªè­˜ç²¾åº¦ã®è¨˜éŒ²

        // ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ã‚’åˆ—æŒ™ã™ã‚‹é–¢æ•°
        async function enumerateMicrophones(userInitiated = false) {
            try {
                // ã¾ãšã¯è¨±å¯ãªã—ã§åˆ—æŒ™ï¼ˆè¨±å¯ãŒç„¡ã„ã¨ label ãŒç©ºã®ã¾ã¾ï¼‰
                let devices = await navigator.mediaDevices.enumerateDevices();

                const hasAnyAudioInput = devices.some(d => d.kind === 'audioinput');
                const hasAnyLabel = devices.some(d => d.kind === 'audioinput' && d.label);
                const hasLiveStream = !!(mediaStream && mediaStream.getTracks().some(t => t.readyState === 'live'));

                // label ãŒå–ã‚Œãªã„ã¨ãã ã‘ã€å¿…è¦ãªã‚‰è¨±å¯ã‚’å–ã‚Šã«è¡Œã
                // NOTE: file:// ã‚„ä¸€éƒ¨ç’°å¢ƒã§ã¯ Permissions API ãŒ 'unknown' ã‚’è¿”ã—ã‚„ã™ã„ã€‚
                //   - userInitiated=trueï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒœã‚¿ãƒ³/ã‚¯ãƒªãƒƒã‚¯ã§æ˜ç¤ºçš„ã«è¦æ±‚ï¼‰ãªã‚‰å–å¾—ã‚’è©¦ã™
                //   - ãã‚Œä»¥å¤–ã¯ã€Œä»¥å‰ã«è¨±å¯æ¸ˆã¿ã€ã®ã¨ãã ã‘å–å¾—ã‚’è©¦ã™ï¼ˆãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—æŠ‘æ­¢ï¼‰
                const previouslyGranted = localStorage.getItem(MIC_PERMISSION_CACHE_KEY) === 'true';
                if (hasAnyAudioInput && !hasAnyLabel && !hasLiveStream) {
                    // ä¸è¦ãªè¨±å¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é¿ã‘ã‚‹ãŸã‚ã€è‡ªå‹•å–å¾—ã¯è¡Œã‚ãªã„ã€‚
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ˜ç¤ºæ“ä½œã—ãŸã¨ãã®ã¿ getUserMedia ã‚’å‘¼ã¶ã€‚
                    if (userInitiated) {
                        await getSelectedMicrophone(true);
                        devices = await navigator.mediaDevices.enumerateDevices();
                    }
                }

                availableMicrophones = devices.filter(device => device.kind === 'audioinput');
                
                const select = document.getElementById('microphoneSelect');
                select.innerHTML = '<option value="default">Default microphone</option>';
                
                availableMicrophones.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Mic ${device.deviceId.substr(0, 8)}`;
                    select.appendChild(option);
                });

                // ä»¥å‰é¸æŠã—ãŸãƒã‚¤ã‚¯ã‚’å¾©å…ƒï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ï¼‰
                const savedDeviceId = localStorage.getItem(MIC_SELECTED_DEVICE_ID_KEY);
                if (savedDeviceId) {
                    const hasOption = Array.from(select.options).some(o => o.value === savedDeviceId);
                    if (hasOption) {
                        select.value = savedDeviceId;
                    }
                }
                
                updateStatus(`Found ${availableMicrophones.length + 1} microphones`);
            } catch (error) {
                console.error('ãƒã‚¤ã‚¯åˆ—æŒ™ã‚¨ãƒ©ãƒ¼:', error);
                updateStatus('Microphone access is not granted');
            }
        }

        // ãƒã‚¤ã‚¯ãƒªã‚¹ãƒˆã‚’æ›´æ–°
        async function refreshMicrophones() {
            updateStatus('Searching for microphones...');
            await enumerateMicrophones(true);
        }

        // é¸æŠã•ã‚ŒãŸãƒã‚¤ã‚¯ã§ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å–å¾—
        async function getSelectedMicrophone(userInitiated = false) {
            try {
                const selectedDeviceId = document.getElementById('microphoneSelect').value;

                const previouslyGranted = localStorage.getItem(MIC_PERMISSION_CACHE_KEY) === 'true';
                const perm = await getMicrophonePermissionState();

                const hadGrant = micEverGrantedThisSession || previouslyGranted;

                if (perm === 'denied') {
                    updateStatus('âŒ Microphone permission is required (check your browser site settings)');
                    return false;
                }

                // è‡ªå‹•å‡¦ç†ï¼ˆåˆ—æŒ™/ç›£è¦–/è‡ªå‹•é–‹å§‹ï¼‰ã‹ã‚‰ã¯è¨±å¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å‡ºã•ãªã„
                // - 'prompt' ã¯ç¢ºå®Ÿã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«ãªã‚Šå¾—ã‚‹ãŸã‚åœæ­¢
                // - 'unknown' ã¯ file:// ç­‰ã§å¸¸ã«è¿”ã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ã€Œä»¥å‰ã«è¨±å¯æ¸ˆã¿ã€ã®å ´åˆã®ã¿è©¦ã™
                if (!userInitiated) {
                    // Permissions API ãŒç’°å¢ƒã«ã‚ˆã‚Šä¸å®‰å®šãªãŸã‚ã€"ä»¥å‰ã«è¨±å¯æ¸ˆã¿" ã®å ´åˆã¯å–å¾—ã‚’è©¦ã™
                    if (perm === 'prompt' && !previouslyGranted) {
                        updateStatus('âš ï¸ Microphone permission is not confirmed, so auto-acquire is stopped. Click Start to grant permission if needed.');
                        return false;
                    }
                    if (perm === 'unknown' && !previouslyGranted) {
                        updateStatus('âš ï¸ Microphone permission is not confirmed, so auto-acquire is stopped. Click Start to grant permission if needed.');
                        return false;
                    }
                }

                // userInitiated=true ã®å ´åˆã¯ã€'prompt'/'unknown' ã§ã‚‚å–å¾—ã‚’è©¦ã™ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ˜ç¤ºæ“ä½œï¼‰
                if (userInitiated && hadGrant && (perm === 'prompt')) {
                    // ã“ã“ã§æ­¢ã‚ãªã„ï¼ˆå†è¨±å¯ãŒå¿…è¦ãªã‚±ãƒ¼ã‚¹ã«å¯¾å¿œï¼‰
                    updateStatus('Microphone permission may be required again. If prompted, please allow it.');
                }

                // åŒã˜ãƒ‡ãƒã‚¤ã‚¹ã§ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒç”Ÿãã¦ã„ã‚‹ãªã‚‰å†å–å¾—ã—ãªã„ï¼ˆè¨±å¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—æŠ‘æ­¢ï¼‰
                if (
                    mediaStream &&
                    currentMicDeviceId === selectedDeviceId &&
                    mediaStream.getTracks().some(t => t.readyState === 'live')
                ) {
                    updateStatus('Microphone ready');
                    return true;
                }

                // å–å¾—ä¸­ãªã‚‰å¤šé‡å–å¾—ã‚’é¿ã‘ã‚‹
                if (micStreamPromise) {
                    await micStreamPromise;
                    return !!mediaStream;
                }

                micStreamPromise = (async () => {
                    // ãƒ‡ãƒã‚¤ã‚¹åˆ‡æ›¿æ™‚ã®ã¿æ—¢å­˜ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åœæ­¢
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                        mediaStream = null;
                        disconnectMicLevelMeter();
                    }

                    const constraints = {
                        audio: selectedDeviceId === 'default' ? true : { deviceId: { exact: selectedDeviceId } }
                    };

                    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                    currentMicDeviceId = selectedDeviceId;
                    micEverGrantedThisSession = true;
                    localStorage.setItem(MIC_PERMISSION_CACHE_KEY, 'true');
                    updateStatus('Microphone ready');

                    // å¯èƒ½ãªã‚‰ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®keep-aliveã‚’æ¥ç¶šï¼ˆAudioContextã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã«æœ‰åŠ¹åŒ–ã•ã‚Œã‚‹ã“ã¨ãŒå¤šã„ï¼‰
                    tryConnectMicKeepAlive();

                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§å–å¾—ã—ãŸå ´åˆã¯ãƒ¬ãƒ™ãƒ«ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚‚æ¥ç¶šã‚’è©¦ã™
                    if (userInitiated) {
                        connectMicLevelMeter();
                    }
                })();

                await micStreamPromise;
                return true;
            } catch (error) {
                console.error('ãƒã‚¤ã‚¯å–å¾—ã‚¨ãƒ©ãƒ¼:', error);

                const previouslyGranted = localStorage.getItem(MIC_PERMISSION_CACHE_KEY) === 'true';
                const isPermissionError =
                    error?.name === 'NotAllowedError' ||
                    error?.name === 'SecurityError' ||
                    /not\s*allowed|permission|denied/i.test(String(error?.message || error));

                // ä»¥å‰ã¯è¨±å¯ã§ãã¦ã„ãŸã®ã«æ¨©é™ç³»ã§å¤±æ•—ã—ãŸå ´åˆã ã‘ã€Œæ¨©é™ãŒå¤±ã‚ã‚ŒãŸã€ã¨åˆ¤æ–­ã™ã‚‹
                if (previouslyGranted && isPermissionError) {
                    micEverGrantedThisSession = false;
                    localStorage.setItem(MIC_PERMISSION_CACHE_KEY, 'false');
                    updateStatus('âš ï¸ Microphone permission was lost. This page will not re-request permission automatically. Reload the page and click Start to grant permission again.');
                    return false;
                }

                // åˆå›è¨±å¯ãŒå–ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ã€æœªè¨±å¯ã¨ã—ã¦æ‰±ã†ï¼ˆæ—¢ã«è¨±å¯æ¸ˆã¿ãªã‚‰ä¿æŒï¼‰
                if (!micEverGrantedThisSession && localStorage.getItem(MIC_PERMISSION_CACHE_KEY) !== 'true') {
                    localStorage.setItem(MIC_PERMISSION_CACHE_KEY, 'false');
                }
                updateStatus('Cannot access the selected microphone');
                return false;
            } finally {
                micStreamPromise = null;
            }
        }

        function scheduleRecognitionRestart(reason = 'unknown') {
            if (!document.getElementById('continuousMode').checked) return;
            if (!isRecognizing) return;
            if (!recognition) return;

            // å®Ÿè¡Œä¸­/é–‹å§‹å‡¦ç†ä¸­ã« start() ã‚’é‡ã­ã‚‹ã¨ InvalidStateError ã«ãªã‚‹
            if (recognitionIsActive || recognitionStartPending) return;

            if (recognitionRestartTimer) {
                clearTimeout(recognitionRestartTimer);
            }

            const delay = Math.min(recognitionRestartDelayMs, 4000);
            recognitionRestartTimer = setTimeout(() => {
                try {
                    if (!isRecognizing) return;
                    if (!document.getElementById('continuousMode').checked) return;
                    if (recognitionIsActive || recognitionStartPending) return;
                    recognitionStartPending = true;
                    // ã“ã“ã§ getUserMedia ã¯å‘¼ã°ãªã„ï¼ˆè¨±å¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å¢—æ®–ã®åŸå› ï¼‰
                    recognition.start();
                } catch (e) {
                    console.error('å†é–‹ã‚¨ãƒ©ãƒ¼:', e, 'reason:', reason);
                } finally {
                    // onstart ãŒæ¥ã‚Œã°ãã“ã§ false ã«æˆ»ã™ãŒã€å¤±æ•—æ™‚ã‚‚è§£æ”¾ã™ã‚‹
                    if (!recognitionIsActive) {
                        recognitionStartPending = false;
                    }
                }
            }, delay);

            recognitionRestartDelayMs = Math.min(recognitionRestartDelayMs * 2, 4000);
        }

        function resetRecognitionRestartBackoff() {
            recognitionRestartDelayMs = 250;
            if (recognitionRestartTimer) {
                clearTimeout(recognitionRestartTimer);
                recognitionRestartTimer = null;
            }
        }

        async function getMicrophonePermissionState() {
            try {
                if (!navigator.permissions || !navigator.permissions.query) {
                    return 'unknown';
                }
                const status = await navigator.permissions.query({ name: 'microphone' });
                return status.state; // 'granted' | 'denied' | 'prompt'
            } catch {
                return 'unknown';
            }
        }

        function ensureAudioContext() {
            try {
                if (!audioContext) {
                    const Ctx = window.AudioContext || window.webkitAudioContext;
                    if (!Ctx) return null;
                    audioContext = new Ctx();
                }
                return audioContext;
            } catch {
                return null;
            }
        }

        function tryConnectMicKeepAlive() {
            if (!mediaStream) return;
            const ctx = ensureAudioContext();
            if (!ctx) return;

            // Autoplayåˆ¶é™ç­‰ã§suspendedã®ã“ã¨ãŒã‚ã‚‹
            if (ctx.state === 'suspended') {
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã«resumeã•ã‚Œã‚‹æƒ³å®š
            }

            try {
                if (keepAliveSourceNode) {
                    // æ—¢å­˜ãƒãƒ¼ãƒ‰ã‚’ç½®ãæ›ãˆã‚‹
                    try { keepAliveSourceNode.disconnect(); } catch {}
                }
                if (!keepAliveGainNode) {
                    keepAliveGainNode = ctx.createGain();
                    keepAliveGainNode.gain.value = 0; // ç„¡éŸ³
                    // destinationã¸ç¹‹ãã¨ã€Œå†ç”Ÿã€æ‰±ã„ã«ãªã‚‹ç’°å¢ƒãŒã‚ã‚‹ã®ã§ã€connectã¯æœ€å°é™ã«
                    keepAliveGainNode.connect(ctx.destination);
                }

                keepAliveSourceNode = ctx.createMediaStreamSource(mediaStream);
                keepAliveSourceNode.connect(keepAliveGainNode);
            } catch (e) {
                console.warn('keep-aliveæ¥ç¶šã«å¤±æ•—:', e);
            }
        }

        function setMicLevelUI(level01) {
            const fill = document.getElementById('micLevelFill');
            const text = document.getElementById('micLevelText');
            const pct = Math.max(0, Math.min(1, Number(level01) || 0));
            const pct100 = Math.round(pct * 100);
            if (fill) fill.style.width = pct100 + '%';
            if (text) text.textContent = pct100 + '%';
        }

        function disconnectMicLevelMeter() {
            if (micLevelRafId) {
                cancelAnimationFrame(micLevelRafId);
                micLevelRafId = null;
            }
            micLevelData = null;
            micLevelSmoothed = 0;

            if (micLevelSourceNode) {
                try { micLevelSourceNode.disconnect(); } catch {}
                micLevelSourceNode = null;
            }
            if (micLevelAnalyserNode) {
                try { micLevelAnalyserNode.disconnect(); } catch {}
                micLevelAnalyserNode = null;
            }
            setMicLevelUI(0);
        }

        function connectMicLevelMeter() {
            if (!mediaStream) return;
            const ctx = ensureAudioContext();
            if (!ctx) return;

            // æ—¢å­˜ãŒã‚ã‚Œã°ä½œã‚Šç›´ã™
            disconnectMicLevelMeter();

            try {
                micLevelSourceNode = ctx.createMediaStreamSource(mediaStream);
                micLevelAnalyserNode = ctx.createAnalyser();
                micLevelAnalyserNode.fftSize = 1024;
                micLevelAnalyserNode.smoothingTimeConstant = 0.8;
                micLevelData = new Uint8Array(micLevelAnalyserNode.fftSize);

                micLevelSourceNode.connect(micLevelAnalyserNode);

                const tick = () => {
                    if (!micLevelAnalyserNode || !micLevelData) return;
                    micLevelAnalyserNode.getByteTimeDomainData(micLevelData);

                    // RMS ã‚’ 0..1 ã«æ­£è¦åŒ–
                    let sumSq = 0;
                    for (let i = 0; i < micLevelData.length; i++) {
                        const v = (micLevelData[i] - 128) / 128;
                        sumSq += v * v;
                    }
                    const rms = Math.sqrt(sumSq / micLevelData.length);

                    // è¦‹ã‚„ã™ã„ã‚ˆã†å°‘ã—æŒã¡ä¸Šã’ï¼ˆç„¡éŸ³ä»˜è¿‘ã‚’æ½°ã—ã™ããªã„ï¼‰
                    const boosted = Math.min(1, rms * 2.2);
                    micLevelSmoothed = micLevelSmoothed * 0.85 + boosted * 0.15;
                    setMicLevelUI(micLevelSmoothed);

                    micLevelRafId = requestAnimationFrame(tick);
                };

                micLevelRafId = requestAnimationFrame(tick);
            } catch (e) {
                console.warn('level-meteræ¥ç¶šã«å¤±æ•—:', e);
                disconnectMicLevelMeter();
            }
        }

        async function attemptMicrophoneRecovery() {
            // äº’æ›æ€§ã®ãŸã‚ã«é–¢æ•°ã¯æ®‹ã™ãŒã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã® getUserMedia ã¯å®Ÿè¡Œã—ãªã„ã€‚
            // ï¼ˆè¨±å¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒé¬±é™¶ã—ã„ã€ã¨ã„ã†è¦ä»¶ã«åˆã‚ã›ã‚‹ï¼‰
            if (micRecoveryInProgress) return;
            micRecoveryInProgress = true;
            try {
                // ã“ã“ã§ã¯å¾©æ—§ã—ãªã„ã€‚Start ãƒœã‚¿ãƒ³ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ˜ç¤ºçš„ã«å†æ¥ç¶šã™ã‚‹ã€‚
                return;
            } finally {
                micRecoveryInProgress = false;
            }
        }

        function startMicWatchdog() {
            if (micWatchdogTimer) return;
            micWatchdogTimer = setInterval(async () => {
                if (!isRecognizing) return;
                if (!mediaStream) return;
                const tracks = mediaStream.getAudioTracks();
                if (tracks.length === 0) return;
                const anyLive = tracks.some(t => t.readyState === 'live');
                if (anyLive) return;

                // ãƒˆãƒ©ãƒƒã‚¯ãŒçµ‚äº†ã—ãŸã‚±ãƒ¼ã‚¹ã€‚
                // è‡ªå‹• getUserMedia ã¯è¡Œã‚ãšã€é€šçŸ¥ã ã‘ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œï¼ˆStartï¼‰ã‚’ä¿ƒã™ã€‚
                disconnectMicLevelMeter();
                const now = Date.now();
                if (now - micStreamEndedNotifiedAt > 15000) {
                    micStreamEndedNotifiedAt = now;
                    updateStatus('âš ï¸ Microphone stream ended. Click Start to reconnect.');
                }
            }, 5000);
        }

        // ãƒã‚¤ãƒ†ã‚£ãƒ–ãªè‹±èªè¡¨ç¾ã®æ…£ç”¨çš„è¾æ›¸
        const nativeExpressions = {
            // æ—¥æœ¬èªçš„ãªæ°—é£ã„ã‚„ç¤¾äº¤è¾ä»¤
            'ãŠç–²ã‚Œæ§˜ã§ã—ãŸ': 'Great job today!',
            'ãŠç–²ã‚Œæ§˜': 'Good work!',
            'ã©ã†ã„ãŸã—ã¾ã—ã¦': 'You\'re welcome!',
            'ã™ã¿ã¾ã›ã‚“ã§ã—ãŸ': 'My bad!',
            'ãŠé¡˜ã„ã—ã¾ã™': 'Please!',
            'ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™': 'Looking forward to working with you!',
            'ã„ã„ã§ã™ã­': 'Sounds good!',
            'ãã†ã§ã™ã­': 'That\'s right!',
            'ãªã‚‹ã»ã©': 'I see!',
            'ãã†ã§ã™ã‹': 'Really?',
            'ã”è‹¦åŠ´ã•ã¾ã§ã—ãŸ': 'Thanks for all your hard work!',
            'ãŠæ‰‹ä¼ã„ã—ã¾ã™': 'Let me help you with that',
            
            // æ„Ÿæƒ…è¡¨ç¾
            'å¬‰ã—ã„ã§ã™': 'I\'m so happy!',
            'æ¥½ã—ã‹ã£ãŸã§ã™': 'That was fun!',
            'ã¤ã¾ã‚‰ãªã„ã§ã™': 'That\'s boring',
            'é¢ç™½ã„ã§ã™': 'That\'s interesting!',
            'é§…ã„ã¦ã„ã¾ã™': 'I\'m shocked!',
            'å¿ƒé…ã§ã™': 'I\'m worried',
            'å®‰å¿ƒã—ã¾ã—ãŸ': 'I\'m relieved',
            'å›°ã£ã¦ã„ã¾ã™': 'I\'m in trouble',
            'å¤§å¤‰ã§ã™': 'This is tough!',
            
            // æ—¥å¸¸ä¼šè©±
            'ãŠè…¹ãŒã™ã„ãŸ': 'I\'m hungry',
            'ã®ã©ãŒã‹ã‚ã„ã¦ã„ã¾ã™': 'I\'m thirsty',
            'çœ¼ãŒç–²ã‚Œã¾ã—ãŸ': 'My eyes are tired',
            'é ­ãŒç—›ã„ã§ã™': 'I have a headache',
            'é¢¨é‚ªã‚’ã²ã„ãŸã¿ãŸã„ã§ã™': 'I think I\'m coming down with something',
            'å…ƒæ°—ãŒãªã„ã§ã™': 'I\'m not feeling well',
            'æ°—åˆ†ãŒã„ã„ã§ã™': 'I feel great!',
            
            // ãƒ“ã‚¸ãƒã‚¹ç”¨èª
            'ã„ã‹ãŒã§ã™ã‹': 'How does that sound?',
            'æ¤œè¨ã—ã¾ã—ã‚‡ã†': 'Let\'s think about it',
            'ç¢ºèªã—ã¾ã™': 'I\'ll check on that',
            'é€£çµ¡ã—ã¾ã™': 'I\'ll get back to you',
            'æ‰“ã¡åˆã‚ã›ã—ã¾ã—ã‚‡ã†': 'Let\'s have a meeting',
            'è­°è«–ã—ã¾ã—ã‚‡ã†': 'Let\'s discuss this',
            'ææ¡ˆã—ã¾ã™': 'I\'d like to suggest...',
            'åŒæ„ã—ã¾ã™': 'I agree',
            'åå¯¾ã§ã™': 'I disagree',
            'ç†è§£ã§ãã¾ã›ã‚“': 'I don\'t get it',
            
            // æ™‚é–“è¡¨ç¾
            'ã‚‚ã†ã™ã': 'in a moment',
            'ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„': 'just a sec',
            'æ€¥ã„ã§ã„ã¾ã™': 'I\'m in a hurry',
            'æ™‚é–“ãŒã‚ã‚Šã¾ã›ã‚“': 'I don\'t have time',
            'æ™‚é–“ãŒã‚ã‚‹æ™‚ã«': 'when you have time',
            'ä»Šåº¦': 'next time',
            'ä»Šåº¦ã®åœŸæ›œæ—¥': 'this Saturday',
            'æ¥é€±ã®ç«æ›œæ—¥': 'next Tuesday',
            
            // é£Ÿäº‹é–¢é€£
            'ãŠè…¹ã„ã£ã±ã„': 'I\'m stuffed',
            'ã‚‚ã†å°‘ã—é£Ÿã¹ãŸã„': 'I could eat a little more',
            'ã™ã”ããŠã„ã—ã„': 'This is delicious!',
            'ã¡ã‚‡ã£ã¨è¾›ã„': 'It\'s a bit spicy',
            'ç”œã™ãã¾ã™': 'It\'s too sweet',
            'ã—ã‚‡ã£ã±ã„': 'It\'s salty',
            'ç†±ã™ãã¾ã™': 'It\'s too hot',
            'å†·ãŸã„ã§ã™': 'It\'s cold',
            
            // æ–°ã—ã„æ…£ç”¨è¡¨ç¾
            'ã‚„ã£ã±ã‚Š': 'I knew it!',
            'ã‚„ã£ã¨': 'finally',
            'ã•ã™ãŒ': 'as expected',
            'ãŸã—ã‹ã«': 'indeed',
            'ã„ã¤ã®é–“ã«ã‹': 'before I knew it',
            'ãªã‚“ã¨ãªã': 'somehow',
            'ã‚‚ã—ã‹ã—ã¦': 'maybe',
            'ã‚‚ã—ã‹ã™ã‚‹ã¨': 'it could be that...'
        };
        
        // æ–‡è„ˆç†è§£ç”¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
        const contextPatterns = {
            // æ™‚åˆ»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            'morning': ['æœ', 'æ—©ã„', 'ãŠã¯ã‚ˆã†', 'å‡ºå‹¤'],
            'afternoon': ['æ˜¼', 'åˆå¾Œ', 'ãƒ©ãƒ³ãƒ', 'æ˜­é£Ÿ'],
            'evening': ['å¤•æ–¹', 'å¤œ', 'ã“ã‚“ã°ã‚“', 'å¤•é£Ÿ', 'å¸°å®…'],
            
            // æ„Ÿæƒ…ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            'positive': ['å¬‰ã—ã„', 'æ¥½ã—ã„', 'ã„ã„', 'ç´ æ™´ã‚‰ã—ã„', 'æœ€é«˜'],
            'negative': ['æ‚²ã—ã„', 'ã¤ã‚‰ã„', 'å«Œã ', 'æœ€æ‚ª', 'ã ã‚'],
            
            // ä»•äº‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            'work': ['ä¼šç¤¾', 'ä»•äº‹', 'ä¼šè­°', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ', 'ã‚¿ã‚¹ã‚¯'],
            'casual': ['å‹é”', 'ã‚²ãƒ¼ãƒ ', 'æ¼«ç”»', 'ã‚¢ãƒ‹ãƒ¡', 'è¶£å‘³']
        };
        
        // æ—¥æœ¬èªç¿»è¨³ç”¨ã®åŒ…æ‹¬çš„è¾æ›¸ã¨æ–‡æ³•ãƒ‘ã‚¿ãƒ¼ãƒ³  
        const translationDict = {
            // åŸºæœ¬çš„ãªæŒ¨æ‹¶
            'ã“ã‚“ã«ã¡ã¯': 'Hello',
            'ã‚ã‚ŠãŒã¨ã†': 'Thank you',
            'ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸ': 'Thank you very much',
            'ã•ã‚ˆã†ãªã‚‰': 'Goodbye',
            'ã¯ã˜ã‚ã¾ã—ã¦': 'Nice to meet you',
            'ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™': 'Please treat me favorably',
            'ãŠã¯ã‚ˆã†': 'Good morning',
            'ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™': 'Good morning',
            'ã“ã‚“ã°ã‚“ã¯': 'Good evening',
            'ãŠã‚„ã™ã¿': 'Good night',
            'ãŠã‚„ã™ã¿ãªã•ã„': 'Good night',
            'ã™ã¿ã¾ã›ã‚“': 'Excuse me / Sorry',
            'ã”ã‚ã‚“ãªã•ã„': 'I am sorry',
            'ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“': 'I apologize',
            'ãŠç–²ã‚Œæ§˜': 'Good work / Thank you for your hard work',
            'ãŠç–²ã‚Œæ§˜ã§ã—ãŸ': 'Thank you for your hard work',
            'ã„ã‚‰ã£ã—ã‚ƒã„ã¾ã›': 'Welcome',
            'ã©ã†ã„ãŸã—ã¾ã—ã¦': 'You are welcome',
            'ãŠå…ƒæ°—ã§ã™ã‹': 'How are you?',
            'å…ƒæ°—ã§ã™': 'I am fine',
            'å¤§ä¸ˆå¤«ã§ã™': 'I am okay / It is fine',
            'ã‚ã‹ã‚Šã¾ã—ãŸ': 'I understand',
            'ã‚ã‹ã‚Šã¾ã›ã‚“': 'I do not understand',
            'ã¯ã„': 'Yes',
            'ã„ã„ãˆ': 'No',
            'ã¡ã‚‡ã£ã¨å¾…ã£ã¦': 'Wait a moment',
            'å°‘ã—å¾…ã£ã¦ãã ã•ã„': 'Please wait a moment',
            
            // æ™‚é–“2é–¢é€£
            'ä»Šæ—¥': 'today',
            'æ˜æ—¥': 'tomorrow',
            'æ˜¨æ—¥': 'yesterday',
            'ä»Šæœ': 'this morning',
            'ä»Šå¤œ': 'tonight',
            'æ˜¨å¤œ': 'last night',
            'æ¥é€±': 'next week',
            'å…ˆé€±': 'last week',
            'æ¥æœˆ': 'next month',
            'å…ˆæœˆ': 'last month',
            'æ¥å¹´': 'next year',
            'å»å¹´': 'last year',
            'ä»Š': 'now',
            'å¾Œã§': 'later',
            'æ—©ã': 'early',
            'é…ã': 'late',
            
            // äººç§°ä»£åè©
            'ç§': 'I',
            'ã‚ãªãŸ': 'you',
            'å½¼': 'he',
            'å½¼å¥³': 'she',
            'ç§ãŸã¡': 'we',
            'ã‚ãªãŸãŸã¡': 'you all',
            'å½¼ã‚‰': 'they',
            'ã“ã‚Œ': 'this',
            'ãã‚Œ': 'that',
            'ã‚ã‚Œ': 'that over there',
            'ã“ã“': 'here',
            'ãã“': 'there',
            'ã‚ãã“': 'over there',
            'ã©ã“': 'where',
            'ã„ã¤': 'when',
            'ä½•': 'what',
            'èª°': 'who',
            'ãªãœ': 'why',
            'ã©ã†': 'how',
            
            // åŸºæœ¬å‹•è©
            'ã‚ã‚‹': 'exist / have',
            'ã„ã‚‹': 'exist (animate)',
            'ã™ã‚‹': 'do',
            'ã„ã': 'go',
            'ãã‚‹': 'come',
            'å¸°ã‚‹': 'return',
            'é£Ÿã¹ã‚‹': 'eat',
            'é£²ã‚€': 'drink',
            'è¦‹ã‚‹': 'see / watch',
            'èã': 'listen / hear',
            'è©±ã™': 'speak',
            'èª­ã‚€': 'read',
            'æ›¸ã': 'write',
            'å­¦ã¶': 'learn',
            'æ•™ãˆã‚‹': 'teach',
            'åƒã': 'work',
            'ä¼‘ã‚€': 'rest',
            'å¯ã‚‹': 'sleep',
            'èµ·ãã‚‹': 'wake up',
            'å…¥ã‚‹': 'enter',
            'å‡ºã‚‹': 'exit',
            'ä¸ŠãŒã‚‹': 'go up',
            'ä¸‹ãŒã‚‹': 'go down',
            'æ­¢ã¾ã‚‹': 'stop',
            'å§‹ã¾ã‚‹': 'start',
            'çµ‚ã‚ã‚‹': 'end',
            'æŒã¤': 'hold',
            'ç½®ã': 'place',
            'å–ã‚‹': 'take',
            'ã‚ã’ã‚‹': 'give',
            'ã‚‚ã‚‰ã†': 'receive',
            'è²·ã†': 'buy',
            'å£²ã‚‹': 'sell',
            'ä½œã‚‹': 'make',
            'ä½¿ã†': 'use',
            'æ´—ã†': 'wash',
            'ç€ã‚‹': 'wear',
            'è„±ã': 'take off',
            
            // å½¢å®¹è©
            'å¤§ãã„': 'big',
            'å°ã•ã„': 'small',
            'é«˜ã„': 'tall / expensive',
            'ä½ã„': 'short / cheap',
            'æ–°ã—ã„': 'new',
            'å¤ã„': 'old',
            'è‹¥ã„': 'young',
            'ç¾ã—ã„': 'beautiful',
            'ãã‚‰ã„': 'clean',
            'æ±šã„': 'dirty',
            'æ˜ã‚‹ã„': 'bright',
            'æš—ã„': 'dark',
            'æ¸©ã‹ã„': 'warm',
            'å†·ãŸã„': 'cold',
            'ç†±ã„': 'hot',
            'é¢ç™½ã„': 'interesting',
            'ã¤ã¾ã‚‰ãªã„': 'boring',
            'æ¥½ã—ã„': 'fun',
            'æ‚²ã—ã„': 'sad',
            'å¬‰ã—ã„': 'happy',
            'æ€–ã„': 'scary',
            'ã„ãŸã„': 'painful',
            'ãŠã„ã—ã„': 'delicious',
            'ã¾ãšã„': 'bad tasting',
            'é›£ã—ã„': 'difficult',
            'ç°¡å˜': 'easy',
            'å®‰ã„': 'cheap',
            'é«˜ã„': 'expensive',
            'é ã„': 'far',
            'è¿‘ã„': 'close',
            'å¤šã„': 'many',
            'å°‘ãªã„': 'few',
            'å¤§äº‹': 'important',
            
            // å ´æ‰€ãƒ»å»ºç‰©
            'å®¶': 'house / home',
            'å­¦æ ¡': 'school',
            'ä¼šç¤¾': 'company',
            'ç—…é™¢': 'hospital',
            'ãƒ¬ã‚¹ãƒˆãƒ©ãƒ³': 'restaurant',
            'ã‚³ãƒ³ãƒ“ãƒ‹': 'convenience store',
            'ã‚¹ãƒ¼ãƒ‘ãƒ¼': 'supermarket',
            'é§…': 'station',
            'ç©ºæ¸¯': 'airport',
            'å…¬åœ’': 'park',
            'å›³æ›¸é¤¨': 'library',
            'ç¾è¡“é¤¨': 'art museum',
            'æ˜ ç”»é¤¨': 'movie theater',
            'ãƒ›ãƒ†ãƒ«': 'hotel',
            'éŠ€è¡Œ': 'bank',
            'éƒµä¾¿å±€': 'post office',
            'è­¦å¯Ÿç½²': 'police station',
            'æ¶ˆé˜²ç½²': 'fire station',
            'å¸‚å½¹æ‰€': 'city hall',
            
            // é£Ÿã¹ç‰©ãƒ»é£²ã¿ç‰©
            'ã”é£¯': 'rice / meal',
            'ãƒ‘ãƒ³': 'bread',
            'è‚‰': 'meat',
            'é­š': 'fish',
            'é‡èœ': 'vegetables',
            'æœç‰©': 'fruit',
            'åµ': 'egg',
            'ç‰›ä¹³': 'milk',
            'æ°´': 'water',
            'ãŠèŒ¶': 'tea',
            'ã‚³ãƒ¼ãƒ’ãƒ¼': 'coffee',
            'ã‚¸ãƒ¥ãƒ¼ã‚¹': 'juice',
            'ãƒ“ãƒ¼ãƒ«': 'beer',
            'ãƒ¯ã‚¤ãƒ³': 'wine',
            'æ—¥æœ¬é…’': 'sake',
            'ãŠå¼å½“': 'lunch box',
            'ã‚µãƒ©ãƒ€': 'salad',
            'ã‚¹ãƒ¼ãƒ—': 'soup',
            'ãƒ©ãƒ¼ãƒ¡ãƒ³': 'ramen',
            'ã‚«ãƒ¬ãƒ¼': 'curry',
            'ã‚¹ã‚·': 'sushi',
            'ãƒ†ãƒ³ãƒ—ãƒ©': 'tempura',
            'ç„¼ãè‚‰': 'grilled meat',
            
            // å®¶æ—ãƒ»äººé–¢ä¿‚
            'å®¶æ—': 'family',
            'ä¸¡è¦ª': 'parents',
            'çˆ¶': 'father',
            'æ¯': 'mother',
            'å…„å¼Ÿ': 'brothers',
            'å§‰å¦¹': 'sisters',
            'å­ä¾›': 'child',
            'æ¯å­': 'son',
            'å¨˜': 'daughter',
            'ç¥–çˆ¶': 'grandfather',
            'ç¥–æ¯': 'grandmother',
            'å‹é”': 'friend',
            'å…ˆç”Ÿ': 'teacher',
            'å­¦ç”Ÿ': 'student',
            'ç¤¾å“¡': 'employee',
            'ç¤¾é•·': 'company president',
            'éƒ¨é•·': 'department manager',
            'åŒ»è€…': 'doctor',
            'çœ‹è­·å¸«': 'nurse',
            'è­¦å¯Ÿå®˜': 'police officer',
            'é‹è»¢æ‰‹': 'driver',
            'åº—å“¡': 'store clerk',
            
            // èº«ä½“éƒ¨ä½
            'é ­': 'head',
            'é«®': 'hair',
            'é¡': 'forehead',
            'çœ¼': 'eye',
            'é¼»': 'nose',
            'å£': 'mouth',
            'æ­¯': 'tooth',
            'è€³': 'ear',
            'é¦–': 'neck',
            'è‚©': 'shoulder',
            'è…¿': 'arm',
            'æ‰‹': 'hand',
            'æŒ‡': 'finger',
            'èƒ¸': 'chest',
            'èƒŒä¸­': 'back',
            'ãŠè…¹': 'stomach',
            'è¶³': 'leg / foot',
            'è‡ªé–“': 'knee',
            'å¿ƒè‡“': 'heart',
            'è…¸': 'lung',
            
            // è‰²
            'èµ¤': 'red',
            'é’': 'blue',
            'é»„è‰²': 'yellow',
            'ç·‘': 'green',
            'é»’': 'black',
            'ç™½': 'white',
            'ç°è‰²': 'gray',
            'èŒ¶è‰²': 'brown',
            'ãƒ”ãƒ³ã‚¯': 'pink',
            'ç´«': 'purple',
            'ã‚ªãƒ¬ãƒ³ã‚¸': 'orange',
            
            // æ•°å­—
            'é›¶': 'zero',
            'ä¸€': 'one',
            'äºŒ': 'two',
            'ä¸‰': 'three',
            'å››': 'four',
            'äº”': 'five',
            'å…­': 'six',
            'ä¸ƒ': 'seven',
            'å…«': 'eight',
            'ä¹': 'nine',
            'å': 'ten',
            'ç™¾': 'hundred',
            'åƒ': 'thousand',
            'ä¸‡': 'ten thousand',
            
            // å­£ç¯€ãƒ»å¤©æ°—
            'æ˜¥': 'spring',
            'å¤': 'summer',
            'ç§‹': 'autumn',
            'å†¬': 'winter',
            'å¤©æ°—': 'weather',
            'æ™´ã‚Œ': 'sunny',
            'é›¨': 'rain',
            'é›ª': 'snow',
            'æ›‡ã‚Š': 'cloudy',
            'é¢¨': 'wind',
            'å˜‰': 'storm',
            'æ¸©åº¦': 'temperature',
            
            // äº¤é€šæ‰‹æ®µ
            'è»Š': 'car',
            'é›»è»Š': 'train',
            'ãƒã‚¹': 'bus',
            'ã‚¿ã‚¯ã‚·ãƒ¼': 'taxi',
            'é£›è¡Œæ©Ÿ': 'airplane',
            'è‡ªè»¢è»Š': 'bicycle',
            'ãƒã‚¤ã‚¯': 'motorcycle',
            'åœ°ä¸‹é‰„': 'subway',
            'æ–°å¹¹ç·š': 'bullet train',
            'èˆ¹': 'ship',
            
            // æ„Ÿæƒ…è¡¨ç¾
            'å¬‰ã—ã„': 'happy',
            'æ‚²ã—ã„': 'sad',
            'æ€’ã£ã¦ã„ã‚‹': 'angry',
            'é©šã„ã¦ã„ã‚‹': 'surprised',
            'å¿ƒé…': 'worried',
            'å®‰å¿ƒ': 'relieved',
            'ç–‘ã£ã¦ã„ã‚‹': 'confused',
            'æœŸå¾…ã—ã¦ã„ã‚‹': 'excited',
            'ç–²ã‚Œã¦ã„ã‚‹': 'tired',
            'å…ƒæ°—': 'energetic',
            
            // ãƒ“ã‚¸ãƒã‚¹ç”¨èª
            'ä¼šè­°': 'meeting',
            'ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³': 'presentation',
            'å ±å‘Š': 'report',
            'è³‡æ–™': 'materials',
            'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«': 'schedule',
            'ç· ã‚åˆ‡ã‚Š': 'deadline',
            'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ': 'project',
            'ãƒãƒ¼ãƒ ': 'team',
            'éƒ¨é–€': 'department',
            'ä¼æ¥­': 'company',
            'é¡§å®¢': 'customer',
            'å¥‘ç´„': 'contract',
            'äº¤æ¸‰': 'negotiation',
            'çµæœ': 'result',
            'æˆæœ': 'achievement'
        };
        
        // æ–‡æ³•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç¿»è¨³ãƒ«ãƒ¼ãƒ«
        const grammarPatterns = [
            { pattern: /(.+)ã§ã™$/, replacement: '$1' },
            { pattern: /(.+)ã§ã—ãŸ$/, replacement: '$1 was' },
            { pattern: /(.+)ã¾ã™$/, replacement: '$1' },
            { pattern: /(.+)ã¾ã—ãŸ$/, replacement: '$1 ed' },
            { pattern: /(.+)ã—ãŸ$/, replacement: '$1 did' },
            { pattern: /(.+)ã—ã¦ã„ã¾ã™$/, replacement: '$1 ing' },
            { pattern: /(.+)ã—ã¦ã„ã¾ã—ãŸ$/, replacement: '$1 was ing' },
            { pattern: /(.+)ã‹ã‚‰$/, replacement: 'from $1' },
            { pattern: /(.+)ã¾ã§$/, replacement: 'until $1' },
            { pattern: /(.+)ã¨$/, replacement: 'with $1' },
            { pattern: /(.+)ã«$/, replacement: 'to $1' },
            { pattern: /(.+)ã§$/, replacement: 'at $1' },
            { pattern: /(.+)ãŒ$/, replacement: '$1 is' },
            { pattern: /(.+)ã‚’$/, replacement: '$1 (object)' },
            { pattern: /ã©ã†ã§ã™ã‹/, replacement: 'how is it?' },
            { pattern: /ã©ã“ã§ã™ã‹/, replacement: 'where is it?' },
            { pattern: /ã„ã¤ã§ã™ã‹/, replacement: 'when is it?' },
            { pattern: /ä½•ã§ã™ã‹/, replacement: 'what is it?' },
            { pattern: /èª°ã§ã™ã‹/, replacement: 'who is it?' },
            { pattern: /ãªãœã§ã™ã‹/, replacement: 'why is it?' }
        ];

        function initializeSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                updateStatus('Speech recognition is not supported');
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();

            // æ—¥æœ¬èªèªè­˜ã®ç²¾åº¦å‘ä¸Šè¨­å®š
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 3; // è¤‡æ•°ã®å€™è£œã‚’å–å¾—
            recognition.lang = document.getElementById('languageSelect').value;
            
            // éŸ³å£°èªè­˜ã®å“è³ªå‘ä¸Š
            if (recognition.serviceURI) {
                recognition.serviceURI = 'wss://www.google.com/speech-api/full-duplex/v1/up';
            }

            recognition.onstart = () => {
                isRecognizing = true;
                recognitionIsActive = true;
                recognitionStartPending = false;
                resetRecognitionRestartBackoff();
                updateStatus('ğŸ¤ Listening...');
                document.getElementById('recordingIndicator').style.display = 'block';

                const startBtn = document.getElementById('startButton');
                const stopBtn = document.getElementById('stopButton');
                if (startBtn) startBtn.disabled = true;
                if (stopBtn) stopBtn.disabled = false;
            };

            recognition.onerror = (event) => {
                console.error('éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼:', event.error);

                // stop() ã«ã‚ˆã‚‹ä¸­æ–­ã¯æƒ³å®šå†…
                if (event.error === 'aborted') {
                    return;
                }

                // ç„¡éŸ³ãŒç¶šãã¨ç™ºç”Ÿã—ã‚„ã™ã„ã€‚ã“ã“ã§å†é–‹ start() ã‚’é‡ã­ã‚‹ã¨ InvalidState ã«ãªã‚Šã‚„ã™ã„
                if (event.error === 'no-speech') {
                    updateStatus('â€¦waiting (silence)â€¦');
                    return;
                }

                updateStatus(`âŒ Error: ${event.error}`);
                document.getElementById('recordingIndicator').style.display = 'none';

                // æ¨©é™ç³»ã‚¨ãƒ©ãƒ¼ã¯è‡ªå‹•å†è©¦è¡Œã™ã‚‹ã¨è¨±å¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒç¹°ã‚Šè¿”ã—å‡ºã‚„ã™ã„ã®ã§åœæ­¢
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    isRecognizing = false;
                    autoStarted = false;
                    recognitionIsActive = false;
                    recognitionStartPending = false;
                    updateStatus('âŒ Microphone permission is required (check your browser site settings)');
                    return;
                }

                // ãã®ä»–ã®ä¸€æ™‚çš„ã‚¨ãƒ©ãƒ¼ã¯ getUserMedia ã›ãšã«èªè­˜ã®ã¿å†é–‹
                scheduleRecognitionRestart(event.error);
            };

            recognition.onend = () => {
                document.getElementById('recordingIndicator').style.display = 'none';
                recognitionIsActive = false;
                recognitionStartPending = false;

                if (isRecognizing && document.getElementById('continuousMode').checked) {
                    // onerror ã§ã‚‚ onend ã§ã‚‚ã€ŒåŒã˜å†é–‹ãƒ«ãƒ¼ãƒˆã€ã«çµ±ä¸€ã—ã¦äºŒé‡ start ã‚’é˜²ã
                    scheduleRecognitionRestart('onend');
                    return;
                }

                resetRecognition();
            };

            recognition.onresult = async (event) => {
                let interimTranscript = '';
                const finalChunks = [];
                let bestConfidence = 0;
                let bestTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    
                    // AIã‚‰ã—ã„å€™è£œé¸æŠã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
                    let selectedTranscript = selectBestCandidate(result);
                    let selectedConfidence = result[0].confidence || 0;
                    
                    if (result.isFinal) {
                        // æ—¥æœ¬èªã®æ–‡ç¯€ã‚’æ•´å½¢
                        selectedTranscript = cleanJapaneseText(selectedTranscript);
                        
                        // å­¦ç¿’æ©Ÿèƒ½: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èªå½™ã‚’å­¦ç¿’
                        learnUserVocabulary(selectedTranscript, selectedConfidence);
                        
                        // å­¦ç¿’æ©Ÿèƒ½: éŸ³å£°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ç¿’
                        learnSpeechPatterns(selectedTranscript);

                        finalChunks.push({
                            text: selectedTranscript,
                            confidence: selectedConfidence || 0.5
                        });
                        
                        if (selectedConfidence > bestConfidence) {
                            bestConfidence = selectedConfidence;
                            bestTranscript = selectedTranscript;
                        }
                    } else {
                        interimTranscript += selectedTranscript;
                    }
                }

                // interim ã¯ã€Œè–„ã„ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç¿»è¨³ã€ã¨ã—ã¦åˆ¥æ ã«è¡¨ç¤º
                const interimText = (interimTranscript || '').trim();
                if (interimText) {
                    const processedInterim = processJapaneseTranscript(interimText);
                    showInterimPreview(processedInterim, 0.5);
                    lastSpeechTime = Date.now();
                } else {
                    // interimãŒç©ºã«ãªã£ãŸã¨ãã¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ¶ˆã™ï¼ˆfinalå‡¦ç†ä¸­ã§ã‚‚OKï¼‰
                    clearInterimPreview();
                }

                // final ã¯ã€Œé †åºä¿è¨¼ã‚­ãƒ¥ãƒ¼ã€ã§ç¿»è¨³ï¼†è¡¨ç¤ºï¼ˆè¿½ã„è¶Šã—é˜²æ­¢ï¼‰
                for (const chunk of finalChunks) {
                    const jp = (chunk.text || '').trim();
                    if (!jp) continue;
                    const processedFinal = processJapaneseTranscript(jp);
                    enqueueFinalSubtitle(processedFinal, chunk.confidence || 0.5);
                    lastSpeechTime = Date.now();
                }
            };

            return true;
        }

        // AIã‚‰ã—ã„å­¦ç¿’æ©Ÿèƒ½é–¢æ•°ç¾¤
        
        // æœ€é©ãªå€™è£œã‚’é¸æŠã™ã‚‹AIã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
        function selectBestCandidate(result) {
            if (result.length === 1) {
                return result[0].transcript;
            }
            
            let bestScore = 0;
            let bestTranscript = result[0].transcript;
            
            for (let j = 0; j < Math.min(result.length, 3); j++) {
                const candidate = result[j];
                const confidence = candidate.confidence || 0;
                const transcript = candidate.transcript;
                
                let score = confidence;
                
                // æ—¥æœ¬èªã‚‰ã—ã•ã‚¹ã‚³ã‚¢
                const japaneseScore = /[ã‚-ã‚–ã‚¢-ãƒ¶ä¸€-é¾¯]/.test(transcript) ? 0.15 : 0;
                score += japaneseScore;
                
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å­¦ç¿’æ¸ˆã¿èªå½™ã‚¹ã‚³ã‚¢
                const vocabularyScore = calculateVocabularyScore(transcript);
                score += vocabularyScore;
                
                // æ–‡è„ˆã‚¹ã‚³ã‚¢
                const contextScore = calculateContextScore(transcript);
                score += contextScore;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestTranscript = transcript;
                }
            }
            
            return bestTranscript;
        }
        
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èªå½™ã‚’å­¦ç¿’
        function learnUserVocabulary(text, confidence) {
            const words = text.split(/[ã€€\sã€ã€‚ã€Œã€]+/).filter(word => word.length > 0);
            
            words.forEach(word => {
                if (userVocabulary.has(word)) {
                    const existing = userVocabulary.get(word);
                    userVocabulary.set(word, {
                        count: existing.count + 1,
                        totalConfidence: existing.totalConfidence + confidence,
                        avgConfidence: (existing.totalConfidence + confidence) / (existing.count + 1),
                        lastUsed: Date.now()
                    });
                } else {
                    userVocabulary.set(word, {
                        count: 1,
                        totalConfidence: confidence,
                        avgConfidence: confidence,
                        lastUsed: Date.now()
                    });
                }
            });
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
            localStorage.setItem('userVocabulary', JSON.stringify(Array.from(userVocabulary.entries())));
        }
        
        // éŸ³å£°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ç¿’
        function learnSpeechPatterns(text) {
            // n-gramãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ç¿’ï¼ˆ2-gram, 3-gramï¼‰
            const patterns = extractNGrams(text, 2).concat(extractNGrams(text, 3));
            
            patterns.forEach(pattern => {
                if (speechPatterns.has(pattern)) {
                    speechPatterns.set(pattern, speechPatterns.get(pattern) + 1);
                } else {
                    speechPatterns.set(pattern, 1);
                }
            });
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
            localStorage.setItem('speechPatterns', JSON.stringify(Array.from(speechPatterns.entries())));
        }
        
        // N-gramãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŠ½å‡º
        function extractNGrams(text, n) {
            const grams = [];
            for (let i = 0; i <= text.length - n; i++) {
                grams.push(text.substring(i, i + n));
            }
            return grams;
        }
        
        // èªå½™ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
        function calculateVocabularyScore(text) {
            const words = text.split(/[ã€€\sã€ã€‚ã€Œã€]+/).filter(word => word.length > 0);
            let score = 0;
            
            words.forEach(word => {
                if (userVocabulary.has(word)) {
                    const vocab = userVocabulary.get(word);
                    // ä½¿ç”¨é »åº¦ã¨ä¿¡é ¼åº¦ã«åŸºã¥ã„ã¦ã‚¹ã‚³ã‚¢ç®—å‡º
                    score += Math.min(vocab.count * 0.01, 0.1) + vocab.avgConfidence * 0.05;
                }
            });
            
            return score;
        }
        
        // æ–‡è„ˆã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
        function calculateContextScore(text) {
            let score = 0;
            
            // æ–‡è„ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
            for (const [context, keywords] of Object.entries(contextPatterns)) {
                keywords.forEach(keyword => {
                    if (text.includes(keyword)) {
                        score += 0.05;
                    }
                });
            }
            
            return score;
        }
        
        // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        function loadLearningData() {
            try {
                const vocabData = localStorage.getItem('userVocabulary');
                if (vocabData) {
                    userVocabulary = new Map(JSON.parse(vocabData));
                }
                
                const patternData = localStorage.getItem('speechPatterns');
                if (patternData) {
                    speechPatterns = new Map(JSON.parse(patternData));
                }
                
                console.log(`å­¦ç¿’æ¸ˆã¿èªå½™: ${userVocabulary.size}å€‹, ãƒ‘ã‚¿ãƒ¼ãƒ³: ${speechPatterns.size}å€‹`);
            } catch (error) {
                console.error('å­¦ç¿’ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        // è‡ªå‹•ã§éŸ³å£°èªè­˜ã‚’é–‹å§‹ã™ã‚‹é–¢æ•°
        async function autoStartRecognition() {
            if (autoStarted) return;

            // åˆå›è¨ªå•ã§ã®è‡ªå‹•è¨±å¯è¦æ±‚ã‚’é¿ã‘ã‚‹ï¼ˆè¨±å¯æ¸ˆã¿ã®å†è¨ªã®ã¿è‡ªå‹•é–‹å§‹ï¼‰
            if (localStorage.getItem(MIC_PERMISSION_CACHE_KEY) !== 'true') {
                return;
            }
            
            // è‡ªå‹•é–‹å§‹ã¯ã€æ—¢ã«ãƒšãƒ¼ã‚¸å†…ã§æœ‰åŠ¹ãª mediaStream ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿è¡Œã†
            if (!mediaStream || !mediaStream.getTracks().some(t => t.readyState === 'live')) {
                // ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒç¢ºç«‹ã—ã¦ã„ãªã„å ´åˆã¯è‡ªå‹•é–‹å§‹ã—ãªã„ï¼ˆãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—æŠ‘æ­¢ï¼‰
                return;
            }

            if (!recognition && !initializeSpeechRecognition()) {
                return;
            }

            recognition.lang = document.getElementById('languageSelect').value;
            
            try {
                if (recognitionIsActive || recognitionStartPending) {
                    return;
                }

                recognitionStartPending = true;
                recognition.start();
                autoStarted = true;
                updateStatus('ğŸ¤ Speech recognition auto-started');
            } catch (e) {
                console.error('è‡ªå‹•é–‹å§‹ã‚¨ãƒ©ãƒ¼:', e);
                recognitionStartPending = false;
            }
        }

        // æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆã‚’æ•´å½¢ã™ã‚‹é–¢æ•°
        function cleanJapaneseText(text) {
            // ä¸è¦ãªç©ºç™½ã‚’é™¤å»
            text = text.replace(/\s+/g, '');
            
            // æ•°å­—ã®æ­£è¦åŒ–
            text = text.replace(/ã€/g, 'ã€ ');
            text = text.replace(/ã€‚/g, 'ã€‚ ');
            
            // é€£ç¶šã™ã‚‹å¥èª­ç‚¹ã‚’æ•´ç†
            text = text.replace(/[ã€ã€‚]+/g, (match) => match[0]);
            
            return text.trim();
        }
        
        // æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆã®ç‰¹æ®Šå‡¦ç†
        function processJapaneseTranscript(text) {
            // ã²ã‚‰ãŒãªã®æ­£è¦åŒ–
            text = text.replace(/ã‚“ã§ã™/g, 'ã§ã™');
            text = text.replace(/ã‚“ã§ã—ãŸ/g, 'ã§ã—ãŸ');
            
            // è‹±èªå˜èªã®æ­£è¦åŒ–
            text = text.replace(/[A-Za-z]+/g, (match) => {
                // è‹±å˜èªã¯ãã®ã¾ã¾ä¿æŒ
                return match;
            });
            
            return text;
        }
        
        // ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼é¢¨ã®æ„è¨³é–¢æ•°ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
        function translateJapaneseToEnglish(text) {
            let translation = text;
            let hasTranslation = false;
            
            // 1. ãƒã‚¤ãƒ†ã‚£ãƒ–è¡¨ç¾ã‚’å„ªå…ˆé©ç”¨
            for (const [japanese, nativeEnglish] of Object.entries(nativeExpressions)) {
                if (translation.includes(japanese)) {
                    translation = translation.replace(new RegExp(japanese, 'g'), nativeEnglish);
                    hasTranslation = true;
                }
            }
            
            // 2. æ–‡è„ˆã‚’è€ƒæ…®ã—ãŸç¿»è¨³
            const context = determineContext(text);
            translation = applyContextualTranslation(translation, context);
            
            // 3. åŸºæœ¬è¾æ›¸ç¿»è¨³ï¼ˆæ„è¨³é‡è¦–ï¼‰
            for (const [japanese, english] of Object.entries(translationDict)) {
                if (translation.includes(japanese)) {
                    const contextualEnglish = getContextualTranslation(japanese, english, context);
                    translation = translation.replace(new RegExp(japanese.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), contextualEnglish);
                    hasTranslation = true;
                }
            }
            
            // 4. æ–‡æ³•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ„è¨³é©ç”¨
            translation = applyNativeGrammarPatterns(translation, context);

            // 4.5. åŸºæœ¬çš„ãªæ–‡æ§‹é€ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚‚é©ç”¨ï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³ç¿»è¨³ã®åº•ä¸Šã’ï¼‰
            translation = basicJapaneseTranslation(translation);
            
            // 5. æœªçŸ¥èªã®å‡¦ç†
            translation = translateUnknownWords(translation);
            
            // 6. æœ€çµ‚çš„ãªãƒã‚¤ãƒ†ã‚£ãƒ–é¢¨æ•´å½¢
            translation = finalizeNativeTranslation(translation, text, context, hasTranslation);
                
            // 7. ç¿»è¨³å±¥æ­´ã¸è¨˜éŒ²
            recordTranslationHistory(text, translation, context);

            // 8. è‹±èªå­—å¹•å´ã«æ—¥æœ¬èªãŒæ®‹ã‚‰ãªã„ã‚ˆã†æœ€çµ‚ã‚µãƒ‹ã‚¿ã‚¤ã‚º
            translation = sanitizeEnglishSubtitle(translation, text);

            return translation;
        }

        function sanitizeEnglishSubtitle(candidate, originalText) {
            let t = (candidate || '').toString();

            // "..." (Japanese) ã®ã‚ˆã†ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯è‹±èªå­—å¹•ã¨ã—ã¦ã¯æ—¥æœ¬èªãŒæ®‹ã‚‹ãŸã‚é™¤å»
            t = t.replace(/"[^"]*"\s*\(Japanese\)/g, '').trim();
            t = t.replace(/\(Japanese\)/g, '').trim();

            // è¨˜å·é¡ã®æ•´ç†
            t = t.replace(/[ã€ã€‚ãƒ»ã€Œã€ã€ã€ã€ã€‘]/g, ' ');
            t = t.replace(/\s+/g, ' ').trim();

            // ã¾ã æ—¥æœ¬èªãŒæ®‹ã‚‹å ´åˆã¯ã€è‹±èªå­—å¹•å´ã‹ã‚‰ã¯é™¤å»ï¼ˆæ—¥æœ¬èªè¡¨ç¤ºã‚’é¿ã‘ã‚‹ï¼‰
            if (/[ã-ã‚–ã‚¡-ãƒ¶ä¸€-é¾¯]/.test(t)) {
                t = t.replace(/[ã-ã‚–ã‚¡-ãƒ¶ä¸€-é¾¯]+/g, ' ');
                t = t.replace(/\s+/g, ' ').trim();
            }

            // ä½•ã‚‚æ®‹ã‚‰ãªã‘ã‚Œã°ç°¡æ½”ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if (!t) {
                return '(untranslated)';
            }

            return t;
        }
        
        // æ–‡è„ˆã‚’åˆ¤å®š
        function determineContext(text) {
            const contexts = [];
            
            // æ™‚é–“5ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            const hour = new Date().getHours();
            if (hour < 11) contexts.push('morning');
            else if (hour < 17) contexts.push('afternoon');
            else contexts.push('evening');
            
            // å†…å®¹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            for (const [contextType, keywords] of Object.entries(contextPatterns)) {
                if (keywords.some(keyword => text.includes(keyword))) {
                    contexts.push(contextType);
                }
            }
            
            return contexts;
        }
        
        // æ–‡è„ˆã«å¿œã˜ãŸç¿»è¨³ã‚’é©ç”¨
        function applyContextualTranslation(text, contexts) {
            // æ–‡è„ˆã«å¿œã˜ãŸç‰¹æ®Šãªç¿»è¨³ãƒ«ãƒ¼ãƒ«
            const contextualRules = {
                'morning': {
                    'ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™': 'Good morning!',
                    'ä»Šæ—¥ã‚‚': 'Today again',
                    'æ—©ã„': 'early'
                },
                'evening': {
                    'ã“ã‚“ã°ã‚“ã¯': 'Good evening!',
                    'ãŠç–²ã‚Œæ§˜': 'You must be tired',
                    'é…ã„': 'late'
                },
                'work': {
                    'é ‘å¼µã‚Šã¾ã™': 'I\'ll do my best',
                    'çµ‚ã‚ã‚Šã¾ã—ãŸ': 'I\'m done',
                    'ç¢ºèªã—ã¾ã™': 'I\'ll check'
                },
                'casual': {
                    'é¢ç™½ã„': 'That\'s cool!',
                    'ã™ã”ã„': 'Awesome!',
                    'ã‚„ã°ã„': 'Oh no!'
                }
            };
            
            let result = text;
            contexts.forEach(context => {
                const rules = contextualRules[context];
                if (rules) {
                    for (const [jp, en] of Object.entries(rules)) {
                        result = result.replace(new RegExp(jp, 'g'), en);
                    }
                }
            });
            
            return result;
        }
        
        // æ–‡è„ˆã«å¿œã˜ãŸèªå½™ç¿»è¨³
        function getContextualTranslation(japanese, defaultEnglish, contexts) {
            // æ–‡è„ˆã«å¿œã˜ã¦ã‚ˆã‚Šè‡ªç„¶ãªç¿»è¨³ã‚’é¸æŠ
            const contextualDict = {
                'å¤§ä¸ˆå¤«': {
                    'work': 'It\'s fine',
                    'casual': 'No worries',
                    'default': 'It\'s okay'
                },
                'ã‚ã‚ŠãŒã¨ã†': {
                    'work': 'Thank you',
                    'casual': 'Thanks!',
                    'evening': 'Thanks for today'
                },
                'ã™ã¿ã¾ã›ã‚“': {
                    'work': 'I apologize',
                    'casual': 'Sorry!',
                    'default': 'Excuse me'
                }
            };
            
            if (contextualDict[japanese]) {
                const options = contextualDict[japanese];
                
                // æ–‡è„ˆã«ãƒãƒƒãƒã™ã‚‹ç¿»è¨³ã‚’æ¢ã™
                for (const context of contexts) {
                    if (options[context]) {
                        return options[context];
                    }
                }
                
                return options.default || defaultEnglish;
            }
            
            return defaultEnglish;
        }
        
        // ãƒã‚¤ãƒ†ã‚£ãƒ–æ–‡æ³•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é©ç”¨
        function applyNativeGrammarPatterns(text, contexts) {
            const nativePatterns = [
                // ã‚ˆã‚Šè‡ªç„¶ãªè‹±èªè¡¨ç¾ã«å¤‰æ›
                { pattern: /(.+)ãŒå¥½ãã§ã™/, replacement: 'I love $1', contexts: ['casual'] },
                { pattern: /(.+)ãŒå¥½ãã§ã™/, replacement: 'I like $1', contexts: ['work'] },
                { pattern: /(.+)ã‚’é£Ÿã¹ã¾ã—ãŸ/, replacement: 'I had $1', contexts: ['casual'] },
                { pattern: /(.+)ã‚’é£Ÿã¹ã¾ã—ãŸ/, replacement: 'I ate $1', contexts: ['work'] },
                { pattern: /(.+)ã«è¡Œãã¾ã—ãŸ/, replacement: 'I went to $1' },
                { pattern: /(.+)ã—ãŸã„ã§ã™/, replacement: 'I\'d like to $1' },
                { pattern: /(.+)ãŒã„ã„ã§ã™ã­/, replacement: '$1 is nice!', contexts: ['casual'] },
                { pattern: /(.+)ãŒã„ã„ã§ã™ã­/, replacement: '$1 would be good', contexts: ['work'] },
                { pattern: /(.+)ã§ãã¾ã™ã‹/, replacement: 'Can you $1?' },
                { pattern: /(.+)ãªã‚“ã§ã™ã‹/, replacement: 'What\'s $1?' },
                { pattern: /(.+)ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“/, replacement: '$1 might be...' },
                { pattern: /(.+)ã¯ã©ã†ã§ã™ã‹/, replacement: 'How about $1?' },
                { pattern: /(.+)ã ã¨æ€ã„ã¾ã™/, replacement: 'I think it\'s $1' },
                { pattern: /(.+)ã‹ã‚‰(.+)ã§ã™/, replacement: 'It\'s $2 because of $1' },
                { pattern: /ãã†ã§ã™ã­/, replacement: 'Exactly!' },
                { pattern: /ã©ã†ã—ã‚ˆã†/, replacement: 'What should I do?' },
                { pattern: /ãã‚“ãªã“ã¨ãªã„ã§ã™/, replacement: 'That\'s not true' },
                { pattern: /ã¾ã•ã‹/, replacement: 'No way!' },
                { pattern: /ã‚„ã£ã±ã‚Š/, replacement: 'I knew it!' }
            ];
            
            let result = text;
            
            for (const rule of nativePatterns) {
                if (rule.contexts && !rule.contexts.some(ctx => contexts.includes(ctx))) {
                    continue; // æ–‡è„ˆãŒãƒãƒƒãƒã—ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                }
                
                if (rule.pattern.test(result)) {
                    result = result.replace(rule.pattern, rule.replacement);
                    break; // æœ€åˆã®ãƒãƒƒãƒã§åœæ­¢
                }
            }
            
            return result;
        }
        
        // æœ€çµ‚çš„ãªãƒã‚¤ãƒ†ã‚£ãƒ–é¢¨æ•´å½¢
        function finalizeNativeTranslation(translation, originalText, contexts, hasTranslation) {
            // 1. ç¸®ç´„å½¢ã‚„å£èªçš„è¡¨ç¾ã‚’è¿½åŠ 
            translation = translation
                .replace(/I am /g, "I'm ")
                .replace(/You are /g, "You're ")
                .replace(/It is /g, "It's ")
                .replace(/That is /g, "That's ")
                .replace(/I will /g, "I'll ")
                .replace(/I would /g, "I'd ")
                .replace(/cannot /g, "can't ")
                .replace(/do not /g, "don't ")
                .replace(/does not /g, "doesn't ");
            
            // 2. ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã®è¡¨ç¾èª¿æ•´
            if (contexts.includes('casual')) {
                translation = translation
                    .replace(/very /g, 'really ')
                    .replace(/excellent/g, 'awesome')
                    .replace(/wonderful/g, 'great')
                    .replace(/terrible/g, 'awful');
            }
            
            // 3. æœ€çµ‚æ•´å½¢
            translation = translation
                .replace(/\s+/g, ' ')
                .trim();
                
            // æœ€åˆã®æ–‡å­—ã‚’å¤§æ–‡å­—ã«
            if (translation) {
                translation = translation.charAt(0).toUpperCase() + translation.slice(1);
            }
            
            // ç¿»è¨³ã§ããªã‹ã£ãŸå ´åˆã®å‡¦ç†
            if (!hasTranslation && translation === originalText) {
                const phoneticTranslation = createPhoneticTranslation(originalText);
                if (phoneticTranslation !== originalText) {
                    return phoneticTranslation;
                }
                return `"${originalText}" (Japanese)`;
            }
            
            return translation || `"${originalText}"`;
        }
        
        // ç¿»è¨³å±¥æ­´ã‚’è¨˜éŒ²
        function recordTranslationHistory(original, translated, contexts) {
            translationHistory.push({
                original,
                translated,
                contexts,
                timestamp: Date.now()
            });
            
            // å±¥æ­´ãŒ100ä»¶ã‚’è¶…ãˆãŸã‚‰å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
            if (translationHistory.length > 100) {
                translationHistory.shift();
            }
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
            localStorage.setItem('translationHistory', JSON.stringify(translationHistory));
        }
        
        // æœªçŸ¥ã®å˜èªã‚’å‡¦ç†ã™ã‚‹é–¢æ•°
        function translateUnknownWords(text) {
            let result = text;
            
            // ã‚«ã‚¿ã‚«ãƒŠå¤–æ¥èªã®å‡¦ç†
            result = result.replace(/[ã‚¢-ãƒ¶ãƒ¼]+/g, (match) => {
                // ã‚«ã‚¿ã‚«ãƒŠã¯ãã®ã¾ã¾è‹±èªã¨ã—ã¦æ‰±ã†ã“ã¨ãŒå¤šã„
                return convertKatakanaToEnglish(match);
            });
            
            // æ•°å­—ã®å‡¦ç†
            result = result.replace(/[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒä¸‡]+/g, (match) => {
                return convertJapaneseNumbers(match);
            });
            
            return result;
        }
        
        // ã‚«ã‚¿ã‚«ãƒŠã‚’è‹±èªã«å¤‰æ›
        function convertKatakanaToEnglish(katakana) {
            const katakanaToEnglish = {
                'ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼': 'computer',
                'ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆ': 'internet',
                'ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³': 'smartphone',
                'ã‚¢ãƒ—ãƒª': 'app',
                'ã‚²ãƒ¼ãƒ ': 'game',
                'ãƒŸãƒ¥ãƒ¼ã‚¸ãƒƒã‚¯': 'music',
                'ãƒ“ãƒ‡ã‚ª': 'video',
                'ãƒ†ãƒ¬ãƒ“': 'TV',
                'ãƒ©ã‚¸ã‚ª': 'radio',
                'ã‚«ãƒ¡ãƒ©': 'camera',
                'ãƒ—ãƒªãƒ³ã‚¿ãƒ¼': 'printer',
                'ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰': 'keyboard',
                'ãƒã‚¦ã‚¹': 'mouse',
                'ã‚¹ã‚¯ãƒªãƒ¼ãƒ³': 'screen',
                'ãƒ¢ãƒ‹ã‚¿ãƒ¼': 'monitor',
                'ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼': 'speaker',
                'ãƒ˜ãƒƒãƒ‰ãƒ•ã‚©ãƒ³': 'headphones',
                'ãƒã‚¤ã‚¯': 'microphone',
                'ãƒ•ã‚¡ã‚¤ãƒ«': 'file',
                'ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼': 'folder',
                'ãƒ‡ãƒ¼ã‚¿': 'data',
                'ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢': 'software',
                'ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢': 'hardware',
                'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯': 'network',
                'ã‚·ã‚¹ãƒ†ãƒ ': 'system',
                'ãƒ—ãƒ­ã‚°ãƒ©ãƒ ': 'program',
                'ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ': 'update',
                'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰': 'download',
                'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰': 'upload'
            };
            
            return katakanaToEnglish[katakana] || katakana.toLowerCase();
        }
        
        // æ—¥æœ¬èªã®æ•°å­—ã‚’è‹±èªã«å¤‰æ›
        function convertJapaneseNumbers(japanese) {
            const numberMap = {
                'ä¸€': '1', 'äºŒ': '2', 'ä¸‰': '3', 'å››': '4', 'äº”': '5',
                'å…­': '6', 'ä¸ƒ': '7', 'å…«': '8', 'ä¹': '9', 'å': '10',
                'ç™¾': '100', 'åƒ': '1000', 'ä¸‡': '10000'
            };
            
            // ç°¡å˜ãªæ•°å­—å¤‰æ›ï¼ˆå®Œå…¨ãªå¤‰æ›ã¯è¤‡é›‘ãªã®ã§åŸºæœ¬çš„ãªã‚‚ã®ã®ã¿ï¼‰
            for (const [jp, en] of Object.entries(numberMap)) {
                if (japanese === jp) {
                    return en;
                }
            }
            
            return japanese;
        }
        
        // æ®‹ã£ãŸæ—¥æœ¬èªã‚’å‡¦ç†
        function handleRemainingJapanese(translation, originalText) {
            // æ—¥æœ¬èªãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã®å‡¦ç†
            return translation.replace(/[ã‚-ã‚–ã‚¢-ãƒ¶ä¸€-é¾¯ã€ã€‚ã€Œã€]+/g, (match) => {
                // çŸ­ã„å˜èªã¯ãã®ã¾ã¾ã€é•·ã„æ–‡ç« ã¯ç°¡æ½”ã«è¡¨ç¤º
                if (match.length <= 3) {
                    return `(${match})`; // çŸ­ã„å ´åˆã¯æ‹¬å¼§ã§å›²ã‚€
                } else {
                    return `"${match}"`; // é•·ã„å ´åˆã¯å¼•ç”¨ç¬¦ã§å›²ã‚€
                }
            });
        }
        
        // ç¿»è¨³çµæœã‚’æœ€çµ‚èª¿æ•´
        function finalizeTranslation(translation, originalText, hasTranslation) {
            // è‹±èªã‚‰ã—ã„æ•´å½¢
            translation = translation
                .replace(/\s+/g, ' ')  // è¤‡æ•°ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’ä¸€ã¤ã«
                .replace(/^[a-z]/, (match) => match.toUpperCase())  // æœ€åˆã®æ–‡å­—ã‚’å¤§æ–‡å­—ã«
                .trim();
            
            // ç¿»è¨³ãŒã§ããªã‹ã£ãŸå ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if (!hasTranslation && translation === originalText) {
                // ç°¡å˜ãªéŸ³å†™ã‚’è©¦ã¿ã‚‹
                const phoneticTranslation = createPhoneticTranslation(originalText);
                if (phoneticTranslation !== originalText) {
                    return phoneticTranslation;
                }
                
                // æœ€çµ‚çš„ã«ã€Œæ—¥æœ¬èªã€ã¨ã—ã¦è¡¨ç¤º
                return `"${originalText}" (Japanese)`;
            }
            
            return translation || `"${originalText}"`;
        }
        
        // ç°¡å˜ãªéŸ³å†™å¤‰æ›ï¼ˆé™å®šçš„ï¼‰
        function createPhoneticTranslation(text) {
            // ã‚ˆãä½¿ã‚ã‚Œã‚‹æ—¥æœ¬èªã®éŸ³å†™
            const phoneticMap = {
                'ã‚ã‚ŠãŒã¨ã†': 'arigatou',
                'ã™ã¿ã¾ã›ã‚“': 'sumimasen',
                'ã•ã‚ˆã†ãªã‚‰': 'sayounara',
                'ã“ã‚“ã«ã¡ã¯': 'konnichiwa',
                'ãŠã¯ã‚ˆã†': 'ohayou',
                'ã“ã‚“ã°ã‚“ã¯': 'konbanwa'
            };
            
            for (const [japanese, romaji] of Object.entries(phoneticMap)) {
                if (text.includes(japanese)) {
                    return text.replace(japanese, romaji);
                }
            }
            
            return text;
        }
        
        // åŸºæœ¬çš„ãªæ—¥æœ¬èªæ–‡æ§‹é€ ã®ç¿»è¨³ï¼ˆæ‹¡å¼µç‰ˆï¼‰
        function basicJapaneseTranslation(text) {
            // åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç¿»è¨³
            const basicPatterns = [
                // å¥½ãå«Œã„ã®è¡¨ç¾
                { pattern: /(.+)ãŒå¥½ãã§ã™/, replacement: 'I like $1' },
                { pattern: /(.+)ãŒå«Œã„ã§ã™/, replacement: 'I dislike $1' },
                { pattern: /(.+)ãŒå¥½ã/, replacement: 'I like $1' },
                { pattern: /(.+)ãŒå«Œã„/, replacement: 'I dislike $1' },
                
                // é£Ÿäº‹é–¢é€£
                { pattern: /(.+)ã‚’é£Ÿã¹ã¾ã—ãŸ/, replacement: 'I ate $1' },
                { pattern: /(.+)ã‚’é£²ã¿ã¾ã—ãŸ/, replacement: 'I drank $1' },
                { pattern: /(.+)ã‚’é£Ÿã¹ã‚‹/, replacement: 'eat $1' },
                { pattern: /(.+)ã‚’é£²ã‚€/, replacement: 'drink $1' },
                { pattern: /(.+)ã‚’ä½œã‚Šã¾ã—ãŸ/, replacement: 'I made $1' },
                { pattern: /(.+)ã‚’ä½œã‚‹/, replacement: 'make $1' },
                
                // ç§»å‹•é–¢é€£
                { pattern: /(.+)ã«è¡Œãã¾ã—ãŸ/, replacement: 'I went to $1' },
                { pattern: /(.+)ã‹ã‚‰æ¥ã¾ã—ãŸ/, replacement: 'I came from $1' },
                { pattern: /(.+)ã«è¡Œã/, replacement: 'go to $1' },
                { pattern: /(.+)ã‹ã‚‰æ¥ã‚‹/, replacement: 'come from $1' },
                { pattern: /(.+)ã«å¸°ã‚Šã¾ã—ãŸ/, replacement: 'I returned to $1' },
                { pattern: /(.+)ã«å¸°ã‚‹/, replacement: 'return to $1' },
                
                // å­˜åœ¨è¡¨ç¾
                { pattern: /(.+)ãŒã„ã¾ã™/, replacement: 'There is $1' },
                { pattern: /(.+)ãŒã‚ã‚Šã¾ã™/, replacement: 'There is $1' },
                { pattern: /(.+)ãŒã„ã‚‹/, replacement: 'There is $1' },
                { pattern: /(.+)ãŒã‚ã‚‹/, replacement: 'There is $1' },
                
                // çŠ¶æ…‹è¡¨ç¾
                { pattern: /(.+)ã§ã—ãŸ/, replacement: 'It was $1' },
                { pattern: /(.+)ã§ã™/, replacement: 'It is $1' },
                { pattern: /(.+)ã ã£ãŸ/, replacement: 'It was $1' },
                { pattern: /(.+)ã /, replacement: 'It is $1' },
                
                // è³ªå•è¡¨ç¾
                { pattern: /(.+)ã§ã™ã‹/, replacement: 'Is it $1?' },
                { pattern: /(.+)ã¾ã—ãŸã‹/, replacement: 'Did you $1?' },
                { pattern: /(.+)ã¾ã™ã‹/, replacement: 'Will you $1?' },
                { pattern: /(.+)ã§ã™ã‹ï¼Ÿ/, replacement: 'Is it $1?' },
                
                // æœªæ¥è¡¨ç¾
                { pattern: /(.+)ã—ã¾ã™/, replacement: 'I will $1' },
                { pattern: /(.+)ã™ã‚‹ã¤ã‚‚ã‚Šã§ã™/, replacement: 'I plan to $1' },
                { pattern: /(.+)ã™ã‚‹äºˆå®šã§ã™/, replacement: 'I plan to $1' },
                
                // é€²è¡Œå½¢
                { pattern: /(.+)ã—ã¦ã„ã¾ã™/, replacement: 'I am $1 ing' },
                { pattern: /(.+)ã—ã¦ã„ã‚‹/, replacement: 'I am $1 ing' },
                { pattern: /(.+)ã—ã¦ã„ã¾ã—ãŸ/, replacement: 'I was $1 ing' },
                
                // èƒ½åŠ›è¡¨ç¾
                { pattern: /(.+)ã§ãã¾ã™/, replacement: 'I can $1' },
                { pattern: /(.+)ã§ãã‚‹/, replacement: 'can $1' },
                { pattern: /(.+)ã§ãã¾ã›ã‚“/, replacement: 'I cannot $1' },
                { pattern: /(.+)ã§ããªã„/, replacement: 'cannot $1' },
                
                // å¸Œæœ›è¡¨ç¾
                { pattern: /(.+)ãŸã„ã§ã™/, replacement: 'I want to $1' },
                { pattern: /(.+)ãŸã„/, replacement: 'want to $1' },
                { pattern: /(.+)ãŒæ¬²ã—ã„ã§ã™/, replacement: 'I want $1' },
                { pattern: /(.+)ãŒæ¬²ã—ã„/, replacement: 'want $1' },
                
                // çµŒé¨“è¡¨ç¾
                { pattern: /(.+)ã—ãŸã“ã¨ãŒã‚ã‚Šã¾ã™/, replacement: 'I have $1 before' },
                { pattern: /(.+)ã—ãŸã“ã¨ãŒãªã„/, replacement: 'I have never $1' },
                
                // ç¾©å‹™è¡¨ç¾
                { pattern: /(.+)ãªã‘ã‚Œã°ã„ã‘ã¾ã›ã‚“/, replacement: 'I must $1' },
                { pattern: /(.+)ãªã‘ã‚Œã°ãªã‚‰ãªã„/, replacement: 'I must $1' },
                { pattern: /(.+)ã¹ãã§ã™/, replacement: 'should $1' },
                
                // æ–¹æ³•è¡¨ç¾
                { pattern: /(.+)ã§(.+)ã—ã¾ã™/, replacement: '$1 $2 by $1' },
                { pattern: /(.+)ã‚’ä½¿ã£ã¦(.+)/, replacement: '$2 using $1' },
                
                // æ™‚é–“3è¡¨ç¾
                { pattern: /(.+)ã®æ™‚ã«(.+)/, replacement: '$2 when $1' },
                { pattern: /(.+)ã®å¾Œã§(.+)/, replacement: '$2 after $1' },
                { pattern: /(.+)ã®å‰ã«(.+)/, replacement: '$2 before $1' }
            ];
            
            for (const pattern of basicPatterns) {
                if (pattern.pattern.test(text)) {
                    return text.replace(pattern.pattern, pattern.replacement);
                }
            }
            
            return text;
        }

        async function startRecognition() {
            // ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç¶™ç¶šã‚’å¸Œæœ›ã€ã—ã¦ã„ã‚‹çŠ¶æ…‹ã¨ã—ã¦å…ˆã«ç«‹ã¦ã‚‹
            isRecognizing = true;

            // æ–°ã—ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¨ã—ã¦å¤ã„ç¿»è¨³å‡¦ç†ã‚’ç„¡åŠ¹åŒ–
            finalQueueSessionId++;

            // é¸æŠã•ã‚ŒãŸãƒã‚¤ã‚¯ã‚’å–å¾—
            const micReady = await getSelectedMicrophone(true);
            if (!micReady) {
                isRecognizing = false;
                return;
            }

            if (!recognition && !initializeSpeechRecognition()) {
                return;
            }

            recognition.lang = document.getElementById('languageSelect').value;
            
            try {
                if (recognitionIsActive || recognitionStartPending) {
                    updateStatus('ğŸ¤ Already listening');
                    return;
                }

                // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒã‚ã‚Œã°AudioContextã‚’æœ‰åŠ¹åŒ–ã—ã¦keep-aliveã‚’æ¥ç¶š
                const ctx = ensureAudioContext();
                if (ctx && ctx.state === 'suspended') {
                    try { await ctx.resume(); } catch {}
                }
                tryConnectMicKeepAlive();
                connectMicLevelMeter();

                recognitionStartPending = true;
                recognition.start();
            } catch (e) {
                console.error('é–‹å§‹ã‚¨ãƒ©ãƒ¼:', e);
                updateStatus('Failed to start');
                recognitionStartPending = false;
                isRecognizing = false;
            }
        }

        function stopRecognition() {
            isRecognizing = false;
            autoStarted = false;
            recognitionStartPending = false;
            resetRecognitionRestartBackoff();
            document.getElementById('recordingIndicator').style.display = 'none';

            // ç¿»è¨³ã‚­ãƒ¥ãƒ¼å‡¦ç†ã‚’åœæ­¢ï¼ˆå¤ã„ async ãŒ UI ã‚’è§¦ã‚‰ãªã„ã‚ˆã†ã«ï¼‰
            finalQueueSessionId++;
            finalTranslateQueue = [];

            // interim ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚åœæ­¢
            clearInterimPreview();

            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.error('åœæ­¢ã‚¨ãƒ©ãƒ¼:', e);
                }
            }

            // èªè­˜åœæ­¢æ™‚ã¯ã„ã£ãŸã‚“ 0 ã«æˆ»ã™ï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ä¿æŒã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ï¼‰
            disconnectMicLevelMeter();

            updateStatus('â¹ï¸ Stopped');

            const startBtn = document.getElementById('startButton');
            const stopBtn = document.getElementById('stopButton');
            if (startBtn) startBtn.disabled = false;
            if (stopBtn) stopBtn.disabled = true;
        }

        function resetRecognition() {
            updateStatus('ğŸ”„ Restarting recognition...');
            // è‡ªå‹•å†é–‹ã®ãŸã‚ã€ãƒœã‚¿ãƒ³çŠ¶æ…‹ã®å¤‰æ›´ã¯ä¸è¦
        }

        async function translateWithGoogle(text, targetLang = 'en') {
            const apiKey = document.getElementById('apiKeyInput')?.value?.trim() || '';

            if (!apiKey) {
                return await translateOfflineUnified(text, targetLang);
            }

            try {
                const response = await fetch(`https://translation.googleapis.com/language/translate/v2?key=${encodeURIComponent(apiKey)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        q: text,
                        target: targetLang,
                        format: 'text'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();
                return data?.data?.translations?.[0]?.translatedText || '(untranslated)';
            } catch (error) {
                console.error('Googleç¿»è¨³ã‚¨ãƒ©ãƒ¼:', error);
                updateStatus(`Translation error: ${error.message || error}`);
                return await translateOfflineUnified(text, targetLang);
            }
        }

        async function translateOfflineUnified(text, targetLang = 'en') {
            const sourceLang = (document.getElementById('languageSelect')?.value || 'ja-JP').split('-')[0];

            // æœŸå¾…å€¤: æ—¥æœ¬èªéŸ³å£° â†’ è‹±èªè¡¨ç¤º
            if (sourceLang === 'ja' && targetLang === 'en') {
                return translateJapaneseToEnglish(text);
            }

            // ãã®ä»–è¨€èªã¯ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§ã¯é™å®šçš„ãªã®ã§ã€æœ€ä½é™ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            return '(untranslated)';
        }

        async function translateUnified(text) {
            const autoTranslate = document.getElementById('autoTranslate')?.checked;
            if (!autoTranslate) {
                return '';
            }

            const targetLang = document.getElementById('targetLanguageSelect')?.value || 'en';
            return await translateWithGoogle(text, targetLang);
        }

        async function testApiKey() {
            const apiKey = document.getElementById('apiKeyInput')?.value?.trim() || '';
            if (!apiKey) {
                updateStatus('Please enter an API key');
                return;
            }

            updateStatus('Testing API key...');

            try {
                const translated = await translateWithGoogle('Hello', 'ja');
                if (translated && translated.toLowerCase() !== 'hello') {
                    updateStatus('âœ… API key is valid');
                } else {
                    updateStatus('âš ï¸ API key does not seem to work');
                }
            } catch (e) {
                updateStatus('âŒ Failed to test API key');
            }
        }

        async function displaySubtitles(text, isInterim = false, confidence = 0.5) {
            // äº’æ›ç”¨ï¼ˆæ—§å®Ÿè£…ï¼‰ã€‚ç¾åœ¨ã¯ final/interim ã‚’ãã‚Œãã‚Œå°‚ç”¨ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã«å¯„ã›ã‚‹ã€‚
            if (isInterim) {
                showInterimPreview(text, confidence);
                return;
            }
            enqueueFinalSubtitle(text, confidence);
        }

        function hideSubtitles() {
            const finalContainer = document.getElementById('finalContainer');
            if (finalContainer) finalContainer.classList.add('hidden');
            document.getElementById('translationIndicator')?.classList.add('hidden');
            updateOverallSubtitleVisibility();
        }

        function updateOverallSubtitleVisibility() {
            const container = document.getElementById('subtitleContainer');
            const previewContainer = document.getElementById('previewContainer');
            const finalContainer = document.getElementById('finalContainer');

            const previewVisible = previewContainer && !previewContainer.classList.contains('hidden');
            const finalVisible = finalContainer && !finalContainer.classList.contains('hidden');

            if (!container) return;
            if (previewVisible || finalVisible) {
                container.style.display = 'block';
                container.classList.remove('hidden');
            } else {
                container.style.display = 'none';
                container.classList.add('hidden');
            }
        }

        function setFinalTranslationIndicatorVisible(visible) {
            const indicator = document.getElementById('translationIndicator');
            if (!indicator) return;
            if (visible) indicator.classList.remove('hidden');
            else indicator.classList.add('hidden');
        }

        function setPreviewTranslationIndicatorVisible(visible) {
            const indicator = document.getElementById('previewTranslationIndicator');
            if (!indicator) return;
            if (visible) indicator.classList.remove('hidden');
            else indicator.classList.add('hidden');
        }

        function renderPreviewSubtitles() {
            const previewContainer = document.getElementById('previewContainer');
            const jpEl = document.getElementById('previewJp');
            const enEl = document.getElementById('previewEn');
            const showJp = document.getElementById('showJapanese').checked;
            const showEn = document.getElementById('showEnglish').checked;
            const autoTranslate = document.getElementById('autoTranslate')?.checked;

            if (!previewContainer || !jpEl || !enEl) return;

            if (!lastPreview.jp) {
                previewContainer.classList.add('hidden');
                setPreviewTranslationIndicatorVisible(false);
                updateOverallSubtitleVisibility();
                return;
            }

            previewContainer.classList.remove('hidden');

            if (showJp) {
                jpEl.textContent = lastPreview.jp;
                jpEl.className = 'subtitle-jp interim';
                jpEl.style.display = 'block';
            } else {
                jpEl.style.display = 'none';
            }

            if (showEn && autoTranslate && lastPreview.en) {
                enEl.textContent = lastPreview.en;
                enEl.className = 'subtitle-en interim';
                enEl.style.display = 'block';
            } else {
                enEl.style.display = 'none';
            }

            updateOverallSubtitleVisibility();
        }

        function renderFinalSubtitles() {
            const finalContainer = document.getElementById('finalContainer');
            const jpSubtitle = document.getElementById('subtitleJp');
            const enSubtitle = document.getElementById('subtitleEn');
            const confidenceBar = document.getElementById('confidenceBar');
            const showJp = document.getElementById('showJapanese').checked;
            const showEn = document.getElementById('showEnglish').checked;
            const autoTranslate = document.getElementById('autoTranslate')?.checked;

            if (!finalContainer || !jpSubtitle || !enSubtitle) return;

            if (!lastFinal.jp) {
                finalContainer.classList.add('hidden');
                setFinalTranslationIndicatorVisible(false);
                updateOverallSubtitleVisibility();
                return;
            }

            finalContainer.classList.remove('hidden');

            // ä¿¡é ¼åº¦ãƒãƒ¼
            if (confidenceBar) {
                const clamped = Math.max(0, Math.min(1, Number(lastFinal.confidence) || 0));
                confidenceBar.style.width = (clamped * 100) + '%';
            }

            if (showJp) {
                jpSubtitle.textContent = lastFinal.jp;
                jpSubtitle.className = 'subtitle-jp final';
                jpSubtitle.style.display = 'block';
            } else {
                jpSubtitle.style.display = 'none';
            }

            if (showEn && autoTranslate && lastFinal.en) {
                enSubtitle.textContent = lastFinal.en;
                enSubtitle.className = 'subtitle-en final';
                enSubtitle.style.display = 'block';
            } else {
                enSubtitle.style.display = 'none';
            }

            updateOverallSubtitleVisibility();
        }

        function clearInterimPreview() {
            lastPreview.jp = '';
            lastPreview.en = '';
            lastPreview.confidence = 0.5;
            if (previewDebounceTimer) {
                clearTimeout(previewDebounceTimer);
                previewDebounceTimer = null;
            }
            previewTranslationSeq++;
            setPreviewTranslationIndicatorVisible(false);
            renderPreviewSubtitles();
        }

        function showInterimPreview(jpText, confidence = 0.5) {
            const trimmed = (jpText || '').trim();
            if (!trimmed) {
                clearInterimPreview();
                return;
            }

            lastPreview.jp = trimmed;
            lastPreview.confidence = confidence;
            // interim ã¯ã¾ãšæ—¥æœ¬èªã‚’å³æ™‚è¡¨ç¤º
            renderPreviewSubtitles();

            const showEn = document.getElementById('showEnglish').checked;
            const autoTranslate = document.getElementById('autoTranslate')?.checked;
            if (!showEn || !autoTranslate) {
                lastPreview.en = '';
                setPreviewTranslationIndicatorVisible(false);
                renderPreviewSubtitles();
                return;
            }

            if (previewDebounceTimer) {
                clearTimeout(previewDebounceTimer);
            }

            const mySeq = ++previewTranslationSeq;
            setPreviewTranslationIndicatorVisible(true);
            previewDebounceTimer = setTimeout(async () => {
                try {
                    const targetLang = document.getElementById('targetLanguageSelect')?.value || 'en';
                    const translated = await translateWithGoogle(trimmed, targetLang);
                    if (mySeq !== previewTranslationSeq) return;
                    lastPreview.en = translated;
                } catch (e) {
                    // å¤±æ•—æ™‚ã¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç¿»è¨³ãªã—ã§ç¶™ç¶š
                    if (mySeq !== previewTranslationSeq) return;
                    lastPreview.en = '';
                } finally {
                    if (mySeq === previewTranslationSeq) {
                        setPreviewTranslationIndicatorVisible(false);
                        renderPreviewSubtitles();
                        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¡¨ç¤ºã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
                        if (previewHideTimer) {
                            clearTimeout(previewHideTimer);
                            previewHideTimer = null;
                        }
                        previewHideTimer = setTimeout(() => {
                            // è‡ªå‹•ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆã‚’æ¶ˆã™
                            clearInterimPreview();
                        }, previewDisplaySec * 1000);
                    }
                }
            }, previewDebounceMs);
        }

        function enqueueFinalSubtitle(jpText, confidence = 0.5) {
            const trimmed = (jpText || '').trim();
            if (!trimmed) return;
            finalTranslateQueue.push({ jp: trimmed, confidence: confidence || 0.5 });
            void processFinalTranslateQueue();
        }

        async function processFinalTranslateQueue() {
            if (finalQueueProcessing) return;
            finalQueueProcessing = true;
            const sessionId = finalQueueSessionId;

            try {
                while (finalTranslateQueue.length > 0) {
                    if (sessionId !== finalQueueSessionId) return;

                    const item = finalTranslateQueue.shift();
                    if (!item || !item.jp) continue;

                    lastFinal.jp = item.jp;
                    lastFinal.en = '';
                    lastFinal.confidence = item.confidence || 0.5;

                    // finalã®æ—¥æœ¬èªã‚’å…ˆã«å‡ºã—ã¦ã€Œç¿»è¨³ä¸­ã€ã‚’è¡¨ç¤ºï¼ˆæ¬¡ã®finalã¸ã¯é€²ã¾ãªã„ï¼‰
                    setFinalTranslationIndicatorVisible(true);
                    renderFinalSubtitles();

                    const showEn = document.getElementById('showEnglish').checked;
                    const autoTranslate = document.getElementById('autoTranslate')?.checked;

                    if (showEn && autoTranslate) {
                        const translated = await translateUnified(item.jp);
                        if (sessionId !== finalQueueSessionId) return;
                        lastFinal.en = translated;
                    } else {
                        lastFinal.en = '';
                    }

                    setFinalTranslationIndicatorVisible(false);
                    renderFinalSubtitles();

                    // è‡ªå‹•éè¡¨ç¤ºã®ã‚¿ã‚¤ãƒãƒ¼ï¼ˆfinalã®ã¿ï¼‰
                    clearTimeout(hideTimeout);
                    const duration = parseInt(document.getElementById('maxDurationRange').value) * 1000;
                    hideTimeout = setTimeout(hideSubtitles, duration);
                }
            } finally {
                finalQueueProcessing = false;
            }
        }

        function rerenderAllSubtitles() {
            renderPreviewSubtitles();
            renderFinalSubtitles();
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function toggleControls() {
            document.body.classList.toggle('hide-controls');
        }

        // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã®èª¿æ•´
        document.getElementById('fontSizeRange').addEventListener('input', (e) => {
            const size = e.target.value;

            // final
            const finalJp = document.getElementById('subtitleJp');
            const finalEn = document.getElementById('subtitleEn');
            if (finalJp) finalJp.style.fontSize = size + 'px';
            if (finalEn) finalEn.style.fontSize = (size * 0.85) + 'px';

            // previewï¼ˆå°‘ã—å°ã•ã‚ï¼‰
            const previewJp = document.getElementById('previewJp');
            const previewEn = document.getElementById('previewEn');
            const previewSize = Math.max(12, Math.round(Number(size) * 0.75));
            if (previewJp) previewJp.style.fontSize = previewSize + 'px';
            if (previewEn) previewEn.style.fontSize = Math.max(11, Math.round(previewSize * 0.85)) + 'px';
        });

        // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®å¤‰æ›´æ™‚
        document.getElementById('showJapanese').addEventListener('change', () => {
            rerenderAllSubtitles();
        });

        document.getElementById('showEnglish').addEventListener('change', () => {
            rerenderAllSubtitles();
        });

        document.getElementById('autoTranslate').addEventListener('change', () => {
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç¿»è¨³ã‚‚å«ã‚ã¦å†æç”»ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯å¿…è¦ãªã‚‰å†ç¿»è¨³ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
            if (lastPreview.jp) {
                showInterimPreview(lastPreview.jp, lastPreview.confidence);
            }
            rerenderAllSubtitles();
        });

        // è¨€èªå¤‰æ›´æ™‚
        document.getElementById('languageSelect').addEventListener('change', () => {
            if (isRecognizing) {
                stopRecognition();
                setTimeout(startRecognition, 100);
            }
        });

        // ãƒã‚¤ã‚¯å¤‰æ›´æ™‚
        document.getElementById('microphoneSelect').addEventListener('change', async () => {
            // é¸æŠã‚’ä¿å­˜ï¼ˆæ¬¡å›ãƒ­ãƒ¼ãƒ‰æ™‚ã«å¾©å…ƒï¼‰
            try {
                localStorage.setItem(MIC_SELECTED_DEVICE_ID_KEY, document.getElementById('microphoneSelect').value);
            } catch {}

            if (isRecognizing) {
                isRecognizing = false;
                if (recognition) {
                    recognition.stop();
                }
                // å°‘ã—å¾…ã£ã¦ã‹ã‚‰æ–°ã—ã„ãƒã‚¤ã‚¯ã§å†é–‹
                setTimeout(async () => {
                    autoStarted = false;
                    await autoStartRecognition();
                }, 500);
            } else {
                // èªè­˜ä¸­ã§ãªã„å ´åˆã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹æ˜ç¤ºæ“ä½œã¨ã—ã¦ãƒã‚¤ã‚¯å–å¾—ã‚’è¡Œã†
                //ï¼ˆé¸æŠå¤‰æ›´ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãªã®ã§ true ã‚’æ¸¡ã™ï¼‰
                await getSelectedMicrophone(true);
            }
        });

        // è¡¨ç¤ºç¯„å›²ã‚¬ã‚¤ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
        document.getElementById('showDisplayGuide').addEventListener('change', (e) => {
            const guide = document.getElementById('displayGuide');
            if (e.target.checked) {
                guide.classList.add('show');
            } else {
                guide.classList.remove('show');
            }
        });

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === ' ') {
                e.preventDefault();
                if (isRecognizing) {
                    stopRecognition();
                } else {
                    startRecognition();
                }
            } else if (e.ctrlKey && e.key === 'h') {
                e.preventDefault();
                toggleControls();
            }
        });

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã®åˆæœŸåŒ–
        window.addEventListener('load', async () => {
            // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
            loadLearningData();

            // APIã‚­ãƒ¼ã‚’å¾©å…ƒ
            const savedApiKey = localStorage.getItem('googleTranslateApiKey');
            if (savedApiKey) {
                const input = document.getElementById('apiKeyInput');
                if (input) input.value = savedApiKey;
            }

            // APIã‚­ãƒ¼ã‚’ä¿å­˜
            const apiKeyInput = document.getElementById('apiKeyInput');
            if (apiKeyInput) {
                apiKeyInput.addEventListener('change', (e) => {
                    localStorage.setItem('googleTranslateApiKey', e.target.value || '');
                });
            }

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå…¥ã£ãŸã‚‰ AudioContext ã‚’æœ‰åŠ¹åŒ–ï¼ˆkeep-aliveç”¨ï¼‰
            document.addEventListener('pointerdown', async () => {
                const ctx = ensureAudioContext();
                if (ctx && ctx.state === 'suspended') {
                    try { await ctx.resume(); } catch {}
                }
                tryConnectMicKeepAlive();
            }, { once: true });
            
            initializeSpeechRecognition();
            await enumerateMicrophones();
            updateStatus('âœ… Ready (press â€œStartâ€ if needed)');

            startMicWatchdog();
            
            // è‡ªå‹•ã§éŸ³å£°èªè­˜ã‚’é–‹å§‹
            setTimeout(autoStartRecognition, 1000);
            // Restore persisted display settings
            try {
                const savedMax = localStorage.getItem('maxDisplaySec');
                const maxEl = document.getElementById('maxDurationRange');
                if (savedMax && maxEl) {
                    maxEl.value = savedMax;
                }

                const previewDeb = localStorage.getItem('previewDebounceMs');
                const previewDebEl = document.getElementById('previewDebounceRange');
                const previewDebVal = document.getElementById('previewDebounceValue');
                if (previewDeb && previewDebEl) {
                    previewDebEl.value = previewDeb;
                    previewDebounceMs = Number(previewDeb) || previewDebounceMs;
                }
                if (previewDebVal) previewDebVal.textContent = String(previewDebounceMs);

                const previewDur = localStorage.getItem('previewDisplaySec');
                const previewDurEl = document.getElementById('previewDurationRange');
                const previewDurVal = document.getElementById('previewDurationValue');
                if (previewDur && previewDurEl) {
                    previewDurEl.value = previewDur;
                    previewDisplaySec = Number(previewDur) || previewDisplaySec;
                }
                if (previewDurVal) previewDurVal.textContent = String(previewDisplaySec);

                // Wire change handlers
                if (maxEl) {
                    maxEl.addEventListener('input', (e) => {
                        const v = Number(e.target.value || 8);
                        try { localStorage.setItem('maxDisplaySec', String(v)); } catch {}
                        // Apply immediately to current final hide timer
                        if (hideTimeout) {
                            clearTimeout(hideTimeout);
                            hideTimeout = setTimeout(hideSubtitles, v * 1000);
                        }
                    });
                }

                if (previewDebEl) {
                    previewDebEl.addEventListener('input', (e) => {
                        const v = Number(e.target.value || 350);
                        previewDebounceMs = v;
                        try { localStorage.setItem('previewDebounceMs', String(v)); } catch {}
                        const valEl = document.getElementById('previewDebounceValue');
                        if (valEl) valEl.textContent = String(v);
                    });
                }

                if (previewDurEl) {
                    previewDurEl.addEventListener('input', (e) => {
                        const v = Number(e.target.value || 3);
                        previewDisplaySec = v;
                        try { localStorage.setItem('previewDisplaySec', String(v)); } catch {}
                        const valEl = document.getElementById('previewDurationValue');
                        if (valEl) valEl.textContent = String(v);
                        // adjust any existing preview hide timer
                        if (previewHideTimer) {
                            clearTimeout(previewHideTimer);
                            previewHideTimer = setTimeout(() => clearInterimPreview(), previewDisplaySec * 1000);
                        }
                    });
                }
            } catch (e) {
                console.warn('restore display settings failed', e);
            }
        });

        // ãƒšãƒ¼ã‚¸ã‚’é›¢ã‚Œã‚‹æ™‚ã®å‡¦ç†
        window.addEventListener('beforeunload', () => {
            isRecognizing = false;
            if (recognition) {
                recognition.stop();
            }

            if (micWatchdogTimer) {
                clearInterval(micWatchdogTimer);
                micWatchdogTimer = null;
            }
            
            // ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }

            if (audioContext) {
                try { audioContext.close(); } catch {}
                audioContext = null;
            }
        });
    </script>
</body>
</html>
