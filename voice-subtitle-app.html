<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Speech Subtitles (OBS-ready)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            font-family: 'Noto Sans', 'Noto Sans JP', Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 20px;
        }

        .subtitle-container {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px 20px;
            margin-bottom: 10px;
            max-width: 80%;
            align-self: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .subtitle-jp {
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            line-height: 1.4;
        }

        .subtitle-en {
            color: #ffff99;
            font-size: 20px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            line-height: 1.4;
            font-style: italic;
        }

        .controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 250px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .stop-button {
            background: #f44336;
        }

        .stop-button:hover {
            background: #da190b;
        }

        label {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        select, input[type="range"], input[type="text"] {
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        input[type="text"] {
            width: 100%;
        }

        .mode-label {
            color: #90EE90;
            font-weight: bold;
        }

        .small-button {
            padding: 5px 10px;
            font-size: 12px;
        }

        .refresh-button {
            margin-left: 10px;
        }

        .compact-gap {
            gap: 6px;
        }

        .hidden {
            display: none;
        }

        .api-button {
            background: #2196F3;
        }

        .api-button:hover {
            background: #1976D2;
        }

        .translation-indicator {
            color: #FFA500;
            font-size: 12px;
            text-align: center;
            margin-bottom: 6px;
        }

        .confidence-indicator {
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .confidence-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #44ff44);
            transition: width 0.3s ease;
        }

        .status {
            color: #90EE90;
            font-size: 12px;
            margin-top: 5px;
        }

        .hide-controls .controls {
            display: none;
        }

        .toggle-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .interim {
            opacity: 0.7;
            font-style: italic;
        }

        .final {
            opacity: 1;
            font-style: normal;
        }

        @media (max-width: 768px) {
            .subtitle-jp {
                font-size: 18px;
            }
            
            .subtitle-en {
                font-size: 16px;
            }
            
            .controls {
                font-size: 12px;
                min-width: 200px;
            }
        }

        /* Ë°®Á§∫ÁØÑÂõ≤„Ç¨„Ç§„Éâ */
        .display-area-guide {
            position: fixed;
            bottom: 10%;
            left: 10%;
            right: 10%;
            height: 200px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            pointer-events: none;
            z-index: 1;
            background: rgba(255, 255, 255, 0.02);
            display: none;
        }

        .display-area-guide.show {
            display: block;
        }

        .guide-label {
            position: absolute;
            top: -25px;
            left: 0;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            font-weight: bold;
        }

        .recording-indicator {
            position: fixed;
            top: 15px;
            right: 60px;
            background: rgba(255, 0, 0, 0.1);
            border: 2px solid #ff4444;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <!-- Recording indicator -->
    <div class="recording-indicator" id="recordingIndicator"></div>
    
    <!-- Display area guide -->
    <div class="display-area-guide" id="displayGuide">
        <div class="guide-label">Subtitle area</div>
    </div>

    <div class="container">
        <div class="subtitle-container hidden" id="subtitleContainer">
            <div class="translation-indicator hidden" id="translationIndicator">Translating...</div>
            <div class="subtitle-jp" id="subtitleJp"></div>
            <div class="subtitle-en" id="subtitleEn"></div>
            <div class="confidence-indicator">
                <div class="confidence-bar" id="confidenceBar"></div>
            </div>
        </div>
    </div>

    <button class="toggle-controls" onclick="toggleControls()">Settings</button>

    <div class="controls" id="controls">
        <div class="control-row">
            <span class="mode-label">üé§ Speech recognition</span>
            <button id="startButton" class="small-button" onclick="startRecognition()">Start</button>
            <button id="stopButton" class="small-button stop-button" onclick="stopRecognition()" disabled>Stop</button>
        </div>
        
        <div class="control-row">
            <label for="microphoneSelect">Microphone:</label>
            <select id="microphoneSelect">
                <option value="default">Default microphone</option>
            </select>
            <button onclick="refreshMicrophones()" class="small-button refresh-button">üîÑ</button>
        </div>

        <div class="control-row compact-gap">
            <label for="apiKeyInput">Translation API key:</label>
            <input type="text" id="apiKeyInput" placeholder="Google Translate API key (optional)">
            <button class="small-button api-button" onclick="testApiKey()">Test</button>
        </div>

        <div class="control-row">
            <label for="targetLanguageSelect">Translate to:</label>
            <select id="targetLanguageSelect">
                <option value="en">English</option>
                <option value="ja">Japanese</option>
                <option value="ko">Korean</option>
                <option value="zh">Chinese</option>
                <option value="es">Spanish</option>
                <option value="fr">French</option>
                <option value="de">German</option>
            </select>
        </div>

        <div class="control-row">
            <label for="languageSelect">Recognition language:</label>
            <select id="languageSelect">
                <option value="ja-JP">Japanese</option>
                <option value="en-US">English</option>
                <option value="ko-KR">Korean</option>
                <option value="zh-CN">Chinese (Simplified)</option>
            </select>
        </div>

        <div class="control-row">
            <label>
                <input type="checkbox" id="showJapanese" checked> Japanese subtitles
            </label>
        </div>

        <div class="control-row">
            <label>
                <input type="checkbox" id="showEnglish" checked> English subtitles
            </label>
        </div>

        <div class="control-row">
            <label>
                <input type="checkbox" id="autoTranslate" checked> Auto-translate
            </label>
        </div>

        <div class="control-row">
            <label for="fontSizeRange">Font size:</label>
            <input type="range" id="fontSizeRange" min="14" max="36" value="24">
        </div>

        <div class="control-row">
            <label for="maxDurationRange">Display duration (sec):</label>
            <input type="range" id="maxDurationRange" min="3" max="15" value="8">
        </div>

        <div class="control-row">
            <label>
                <input type="checkbox" id="continuousMode" checked> Continuous recognition
            </label>
        </div>
        <div class="control-row">
            <label>
                <input type="checkbox" id="showDisplayGuide"> Show display guide
            </label>
        </div>
        <div class="status" id="status">Idle...</div>
    </div>

    <script>
        let recognition;
        let isRecognizing = false;
        let recognitionIsActive = false; // SpeechRecognition„ÅåÂÆüË°å‰∏≠„ÅãÔºàonstart„ÄúonendÔºâ
        let recognitionStartPending = false; // start() Âëº„Å≥Âá∫„ÅóÁõ¥Âæå„Äúonstart„Åæ„Åß
        let lastSpeechTime = 0;
        let hideTimeout;
        let currentTranscript = '';
        let finalTranscript = '';
        let mediaStream = null;
        let currentMicDeviceId = null;
        let micStreamPromise = null;
        let availableMicrophones = [];
        let autoStarted = false;

        // „Éû„Ç§„ÇØÊ®©Èôê„ÅÆ„Äå„Åì„ÅÆ„Éö„Éº„Ç∏ÂÜÖ„Åß„ÅÆÂÜçË¶ÅÊ±Ç„Äç„ÇíÈÅø„Åë„Çã„Åü„ÇÅ„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
        const MIC_PERMISSION_CACHE_KEY = 'micPermissionGranted';
        let micEverGrantedThisSession = false;

        let recognitionRestartTimer = null;
        let recognitionRestartDelayMs = 250;

        // ÁøªË®≥ÔºàGoogle Translate API„ÅØ‰ªªÊÑèÔºâ
        let translationRequestSeq = 0;

        // „Éû„Ç§„ÇØ„ÅÆkeep-aliveÔºàÁÑ°Èü≥ÊîæÁΩÆ„Åß„Çπ„Éà„É™„Éº„É†„ÅåËêΩ„Å°„ÇãÁí∞Â¢ÉÂêë„ÅëÔºâ
        let audioContext = null;
        let keepAliveSourceNode = null;
        let keepAliveGainNode = null;
        let micWatchdogTimer = null;
        let micRecoveryInProgress = false;
        let micRecoveryDelayMs = 1000;
        
        // Â≠¶ÁøíÊ©üËÉΩÁî®„ÅÆÂ§âÊï∞
        let userVocabulary = new Map(); // „É¶„Éº„Ç∂„Éº„ÅÆË™ûÂΩô„Éá„Éº„Çø„Éô„Éº„Çπ
        let speechPatterns = new Map(); // Èü≥Â£∞„Éë„Çø„Éº„É≥„ÅÆÂ≠¶Áøí
        let translationHistory = []; // ÁøªË®≥Â±•Ê≠¥
        let recognitionAccuracy = new Map(); // Ë™çË≠òÁ≤æÂ∫¶„ÅÆË®òÈå≤

        // „Éû„Ç§„ÇØ„Éá„Éê„Ç§„Çπ„ÇíÂàóÊåô„Åô„ÇãÈñ¢Êï∞
        async function enumerateMicrophones(userInitiated = false) {
            try {
                // „Åæ„Åö„ÅØË®±ÂèØ„Å™„Åó„ÅßÂàóÊåôÔºàË®±ÂèØ„ÅåÁÑ°„ÅÑ„Å® label „ÅåÁ©∫„ÅÆ„Åæ„ÅæÔºâ
                let devices = await navigator.mediaDevices.enumerateDevices();

                const hasAnyAudioInput = devices.some(d => d.kind === 'audioinput');
                const hasAnyLabel = devices.some(d => d.kind === 'audioinput' && d.label);
                const hasLiveStream = !!(mediaStream && mediaStream.getTracks().some(t => t.readyState === 'live'));

                // label „ÅåÂèñ„Çå„Å™„ÅÑ„Å®„Åç„Å†„Åë„ÄÅÂøÖË¶Å„Å™„ÇâË®±ÂèØ„ÇíÂèñ„Çä„Å´Ë°å„Åè
                // NOTE: file:// „ÇÑ‰∏ÄÈÉ®Áí∞Â¢É„Åß„ÅØ Permissions API „Åå 'unknown' „ÇíËøî„Åó„ÇÑ„Åô„ÅÑ„ÄÇ
                //   - userInitiated=trueÔºà„É¶„Éº„Ç∂„Éº„Åå„Éú„Çø„É≥/„ÇØ„É™„ÉÉ„ÇØ„ÅßÊòéÁ§∫ÁöÑ„Å´Ë¶ÅÊ±ÇÔºâ„Å™„ÇâÂèñÂæó„ÇíË©¶„Åô
                //   - „Åù„Çå‰ª•Â§ñ„ÅØ„Äå‰ª•Ââç„Å´Ë®±ÂèØÊ∏à„Åø„Äç„ÅÆ„Å®„Åç„Å†„ÅëÂèñÂæó„ÇíË©¶„ÅôÔºà„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÊäëÊ≠¢Ôºâ
                const previouslyGranted = localStorage.getItem(MIC_PERMISSION_CACHE_KEY) === 'true';
                if (hasAnyAudioInput && !hasAnyLabel && !hasLiveStream) {
                    if (userInitiated || previouslyGranted) {
                        await getSelectedMicrophone(userInitiated);
                        devices = await navigator.mediaDevices.enumerateDevices();
                    }
                }

                availableMicrophones = devices.filter(device => device.kind === 'audioinput');
                
                const select = document.getElementById('microphoneSelect');
                select.innerHTML = '<option value="default">Default microphone</option>';
                
                availableMicrophones.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Mic ${device.deviceId.substr(0, 8)}`;
                    select.appendChild(option);
                });
                
                updateStatus(`Found ${availableMicrophones.length + 1} microphones`);
            } catch (error) {
                console.error('„Éû„Ç§„ÇØÂàóÊåô„Ç®„É©„Éº:', error);
                updateStatus('Microphone access is not granted');
            }
        }

        // „Éû„Ç§„ÇØ„É™„Çπ„Éà„ÇíÊõ¥Êñ∞
        async function refreshMicrophones() {
            updateStatus('Searching for microphones...');
            await enumerateMicrophones(true);
        }

        // ÈÅ∏Êäû„Åï„Çå„Åü„Éû„Ç§„ÇØ„Åß„É°„Éá„Ç£„Ç¢„Çπ„Éà„É™„Éº„É†„ÇíÂèñÂæó
        async function getSelectedMicrophone(userInitiated = false) {
            try {
                const selectedDeviceId = document.getElementById('microphoneSelect').value;

                const previouslyGranted = localStorage.getItem(MIC_PERMISSION_CACHE_KEY) === 'true';
                const perm = await getMicrophonePermissionState();

                const hadGrant = micEverGrantedThisSession || previouslyGranted;

                if (perm === 'denied') {
                    updateStatus('‚ùå Microphone permission is required (check your browser site settings)');
                    return false;
                }

                // Ëá™ÂãïÂá¶ÁêÜÔºàÂàóÊåô/Áõ£Ë¶ñ/Ëá™ÂãïÈñãÂßãÔºâ„Åã„Çâ„ÅØË®±ÂèØ„Éó„É≠„É≥„Éó„Éà„ÇíÂá∫„Åï„Å™„ÅÑ
                // - 'prompt' „ÅØÁ¢∫ÂÆü„Å´„Éó„É≠„É≥„Éó„Éà„Å´„Å™„ÇäÂæó„Çã„Åü„ÇÅÂÅúÊ≠¢
                // - 'unknown' „ÅØ file:// Á≠â„ÅßÂ∏∏„Å´Ëøî„Çã„Åì„Å®„Åå„ÅÇ„Çã„ÅÆ„Åß„Äå‰ª•Ââç„Å´Ë®±ÂèØÊ∏à„Åø„Äç„ÅÆÂ†¥Âêà„ÅÆ„ÅøË©¶„Åô
                if (!userInitiated) {
                    if (perm === 'prompt') {
                        updateStatus('‚ö†Ô∏è Microphone permission is not confirmed, so auto-acquire is stopped. Click Start to grant permission if needed.');
                        return false;
                    }
                    if (perm === 'unknown' && !previouslyGranted) {
                        updateStatus('‚ö†Ô∏è Microphone permission is not confirmed, so auto-acquire is stopped. Click Start to grant permission if needed.');
                        return false;
                    }
                }

                // userInitiated=true „ÅÆÂ†¥Âêà„ÅØ„ÄÅ'prompt'/'unknown' „Åß„ÇÇÂèñÂæó„ÇíË©¶„ÅôÔºà„É¶„Éº„Ç∂„Éº„ÅÆÊòéÁ§∫Êìç‰ΩúÔºâ
                if (userInitiated && hadGrant && (perm === 'prompt')) {
                    // „Åì„Åì„ÅßÊ≠¢„ÇÅ„Å™„ÅÑÔºàÂÜçË®±ÂèØ„ÅåÂøÖË¶Å„Å™„Ç±„Éº„Çπ„Å´ÂØæÂøúÔºâ
                    updateStatus('Microphone permission may be required again. If prompted, please allow it.');
                }

                // Âêå„Åò„Éá„Éê„Ç§„Çπ„Åß„Çπ„Éà„É™„Éº„É†„ÅåÁîü„Åç„Å¶„ÅÑ„Çã„Å™„ÇâÂÜçÂèñÂæó„Åó„Å™„ÅÑÔºàË®±ÂèØ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÊäëÊ≠¢Ôºâ
                if (
                    mediaStream &&
                    currentMicDeviceId === selectedDeviceId &&
                    mediaStream.getTracks().some(t => t.readyState === 'live')
                ) {
                    updateStatus('Microphone ready');
                    return true;
                }

                // ÂèñÂæó‰∏≠„Å™„ÇâÂ§öÈáçÂèñÂæó„ÇíÈÅø„Åë„Çã
                if (micStreamPromise) {
                    await micStreamPromise;
                    return !!mediaStream;
                }

                micStreamPromise = (async () => {
                    // „Éá„Éê„Ç§„ÇπÂàáÊõøÊôÇ„ÅÆ„ÅøÊó¢Â≠ò„ÅÆ„Çπ„Éà„É™„Éº„É†„ÇíÂÅúÊ≠¢
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                        mediaStream = null;
                    }

                    const constraints = {
                        audio: selectedDeviceId === 'default' ? true : { deviceId: { exact: selectedDeviceId } }
                    };

                    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                    currentMicDeviceId = selectedDeviceId;
                    micEverGrantedThisSession = true;
                    localStorage.setItem(MIC_PERMISSION_CACHE_KEY, 'true');
                    updateStatus('Microphone ready');

                    // ÂèØËÉΩ„Å™„Çâ„Çπ„Éà„É™„Éº„É†„ÅÆkeep-alive„ÇíÊé•Á∂öÔºàAudioContext„ÅØ„É¶„Éº„Ç∂„ÉºÊìç‰ΩúÂæå„Å´ÊúâÂäπÂåñ„Åï„Çå„Çã„Åì„Å®„ÅåÂ§ö„ÅÑÔºâ
                    tryConnectMicKeepAlive();
                })();

                await micStreamPromise;
                return true;
            } catch (error) {
                console.error('„Éû„Ç§„ÇØÂèñÂæó„Ç®„É©„Éº:', error);

                const previouslyGranted = localStorage.getItem(MIC_PERMISSION_CACHE_KEY) === 'true';
                const isPermissionError =
                    error?.name === 'NotAllowedError' ||
                    error?.name === 'SecurityError' ||
                    /not\s*allowed|permission|denied/i.test(String(error?.message || error));

                // ‰ª•Ââç„ÅØË®±ÂèØ„Åß„Åç„Å¶„ÅÑ„Åü„ÅÆ„Å´Ê®©ÈôêÁ≥ª„ÅßÂ§±Êïó„Åó„ÅüÂ†¥Âêà„Å†„Åë„ÄåÊ®©Èôê„ÅåÂ§±„Çè„Çå„Åü„Äç„Å®Âà§Êñ≠„Åô„Çã
                if (previouslyGranted && isPermissionError) {
                    micEverGrantedThisSession = false;
                    localStorage.setItem(MIC_PERMISSION_CACHE_KEY, 'false');
                    updateStatus('‚ö†Ô∏è Microphone permission was lost. This page will not re-request permission automatically. Reload the page and click Start to grant permission again.');
                    return false;
                }

                // ÂàùÂõûË®±ÂèØ„ÅåÂèñ„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„ÄÅÊú™Ë®±ÂèØ„Å®„Åó„Å¶Êâ±„ÅÜÔºàÊó¢„Å´Ë®±ÂèØÊ∏à„Åø„Å™„Çâ‰øùÊåÅÔºâ
                if (!micEverGrantedThisSession && localStorage.getItem(MIC_PERMISSION_CACHE_KEY) !== 'true') {
                    localStorage.setItem(MIC_PERMISSION_CACHE_KEY, 'false');
                }
                updateStatus('Cannot access the selected microphone');
                return false;
            } finally {
                micStreamPromise = null;
            }
        }

        function scheduleRecognitionRestart(reason = 'unknown') {
            if (!document.getElementById('continuousMode').checked) return;
            if (!isRecognizing) return;
            if (!recognition) return;

            // ÂÆüË°å‰∏≠/ÈñãÂßãÂá¶ÁêÜ‰∏≠„Å´ start() „ÇíÈáç„Å≠„Çã„Å® InvalidStateError „Å´„Å™„Çã
            if (recognitionIsActive || recognitionStartPending) return;

            if (recognitionRestartTimer) {
                clearTimeout(recognitionRestartTimer);
            }

            const delay = Math.min(recognitionRestartDelayMs, 4000);
            recognitionRestartTimer = setTimeout(() => {
                try {
                    if (!isRecognizing) return;
                    if (!document.getElementById('continuousMode').checked) return;
                    if (recognitionIsActive || recognitionStartPending) return;
                    recognitionStartPending = true;
                    // „Åì„Åì„Åß getUserMedia „ÅØÂëº„Å∞„Å™„ÅÑÔºàË®±ÂèØ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂ¢óÊÆñ„ÅÆÂéüÂõ†Ôºâ
                    recognition.start();
                } catch (e) {
                    console.error('ÂÜçÈñã„Ç®„É©„Éº:', e, 'reason:', reason);
                } finally {
                    // onstart „ÅåÊù•„Çå„Å∞„Åù„Åì„Åß false „Å´Êàª„Åô„Åå„ÄÅÂ§±ÊïóÊôÇ„ÇÇËß£Êîæ„Åô„Çã
                    if (!recognitionIsActive) {
                        recognitionStartPending = false;
                    }
                }
            }, delay);

            recognitionRestartDelayMs = Math.min(recognitionRestartDelayMs * 2, 4000);
        }

        function resetRecognitionRestartBackoff() {
            recognitionRestartDelayMs = 250;
            if (recognitionRestartTimer) {
                clearTimeout(recognitionRestartTimer);
                recognitionRestartTimer = null;
            }
        }

        async function getMicrophonePermissionState() {
            try {
                if (!navigator.permissions || !navigator.permissions.query) {
                    return 'unknown';
                }
                const status = await navigator.permissions.query({ name: 'microphone' });
                return status.state; // 'granted' | 'denied' | 'prompt'
            } catch {
                return 'unknown';
            }
        }

        function ensureAudioContext() {
            try {
                if (!audioContext) {
                    const Ctx = window.AudioContext || window.webkitAudioContext;
                    if (!Ctx) return null;
                    audioContext = new Ctx();
                }
                return audioContext;
            } catch {
                return null;
            }
        }

        function tryConnectMicKeepAlive() {
            if (!mediaStream) return;
            const ctx = ensureAudioContext();
            if (!ctx) return;

            // AutoplayÂà∂ÈôêÁ≠â„Åßsuspended„ÅÆ„Åì„Å®„Åå„ÅÇ„Çã
            if (ctx.state === 'suspended') {
                // „É¶„Éº„Ç∂„ÉºÊìç‰ΩúÂæå„Å´resume„Åï„Çå„ÇãÊÉ≥ÂÆö
            }

            try {
                if (keepAliveSourceNode) {
                    // Êó¢Â≠ò„Éé„Éº„Éâ„ÇíÁΩÆ„ÅçÊèõ„Åà„Çã
                    try { keepAliveSourceNode.disconnect(); } catch {}
                }
                if (!keepAliveGainNode) {
                    keepAliveGainNode = ctx.createGain();
                    keepAliveGainNode.gain.value = 0; // ÁÑ°Èü≥
                    // destination„Å∏Áπã„Åê„Å®„ÄåÂÜçÁîü„ÄçÊâ±„ÅÑ„Å´„Å™„ÇãÁí∞Â¢É„Åå„ÅÇ„Çã„ÅÆ„Åß„ÄÅconnect„ÅØÊúÄÂ∞èÈôê„Å´
                    keepAliveGainNode.connect(ctx.destination);
                }

                keepAliveSourceNode = ctx.createMediaStreamSource(mediaStream);
                keepAliveSourceNode.connect(keepAliveGainNode);
            } catch (e) {
                console.warn('keep-aliveÊé•Á∂ö„Å´Â§±Êïó:', e);
            }
        }

        async function attemptMicrophoneRecovery() {
            if (micRecoveryInProgress) return;
            micRecoveryInProgress = true;

            try {
                const perm = await getMicrophonePermissionState();
                if (perm === 'denied' || perm === 'prompt') {
                    updateStatus('‚ùå Microphone permission is required (check your browser site settings)');
                    return;
                }

                // 'unknown' „ÅØ file:// Á≠â„ÅßÂ∏∏„Å´Ëøî„Çã„Åì„Å®„Åå„ÅÇ„Çã„ÅÆ„Åß„ÄÅ‰ª•Ââç„Å´Ë®±ÂèØÊ∏à„Åø„Å™„ÇâÂæ©Êóß„ÇíË©¶„Åô
                if (perm === 'unknown' && localStorage.getItem(MIC_PERMISSION_CACHE_KEY) !== 'true') {
                    updateStatus('‚ùå Microphone permission is required (check your browser site settings)');
                    return;
                }

                updateStatus('üîÑ Reconnecting microphone...');
                const ok = await getSelectedMicrophone(false);
                if (ok) {
                    micRecoveryDelayMs = 1000;
                    updateStatus('‚úÖ Microphone reconnected');
                } else {
                    micRecoveryDelayMs = Math.min(micRecoveryDelayMs * 2, 10000);
                }
            } finally {
                micRecoveryInProgress = false;
            }
        }

        function startMicWatchdog() {
            if (micWatchdogTimer) return;
            micWatchdogTimer = setInterval(async () => {
                if (!isRecognizing) return;
                if (!mediaStream) return;
                const tracks = mediaStream.getAudioTracks();
                if (tracks.length === 0) return;
                const anyLive = tracks.some(t => t.readyState === 'live');
                if (anyLive) return;

                // ÁÑ°Èü≥ÊîæÁΩÆÁ≠â„Åß„Éà„É©„ÉÉ„ÇØ„ÅåÁµÇ‰∫Ü„Åó„Åü„Ç±„Éº„Çπ
                setTimeout(attemptMicrophoneRecovery, micRecoveryDelayMs);
            }, 5000);
        }

        // „Éç„Ç§„ÉÜ„Ç£„Éñ„Å™Ëã±Ë™ûË°®Áèæ„ÅÆÊÖ£Áî®ÁöÑËæûÊõ∏
        const nativeExpressions = {
            // Êó•Êú¨Ë™ûÁöÑ„Å™Ê∞óÈÅ£„ÅÑ„ÇÑÁ§æ‰∫§Ëæû‰ª§
            '„ÅäÁñ≤„ÇåÊßò„Åß„Åó„Åü': 'Great job today!',
            '„ÅäÁñ≤„ÇåÊßò': 'Good work!',
            '„Å©„ÅÜ„ÅÑ„Åü„Åó„Åæ„Åó„Å¶': 'You\'re welcome!',
            '„Åô„Åø„Åæ„Åõ„Çì„Åß„Åó„Åü': 'My bad!',
            '„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô': 'Please!',
            '„Çà„Çç„Åó„Åè„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô': 'Looking forward to working with you!',
            '„ÅÑ„ÅÑ„Åß„Åô„Å≠': 'Sounds good!',
            '„Åù„ÅÜ„Åß„Åô„Å≠': 'That\'s right!',
            '„Å™„Çã„Åª„Å©': 'I see!',
            '„Åù„ÅÜ„Åß„Åô„Åã': 'Really?',
            '„ÅîËã¶Âä¥„Åï„Åæ„Åß„Åó„Åü': 'Thanks for all your hard work!',
            '„ÅäÊâã‰ºù„ÅÑ„Åó„Åæ„Åô': 'Let me help you with that',
            
            // ÊÑüÊÉÖË°®Áèæ
            'Â¨â„Åó„ÅÑ„Åß„Åô': 'I\'m so happy!',
            'Ê•Ω„Åó„Åã„Å£„Åü„Åß„Åô': 'That was fun!',
            '„Å§„Åæ„Çâ„Å™„ÅÑ„Åß„Åô': 'That\'s boring',
            'Èù¢ÁôΩ„ÅÑ„Åß„Åô': 'That\'s interesting!',
            'ÈßÖ„ÅÑ„Å¶„ÅÑ„Åæ„Åô': 'I\'m shocked!',
            'ÂøÉÈÖç„Åß„Åô': 'I\'m worried',
            'ÂÆâÂøÉ„Åó„Åæ„Åó„Åü': 'I\'m relieved',
            'Âõ∞„Å£„Å¶„ÅÑ„Åæ„Åô': 'I\'m in trouble',
            'Â§ßÂ§â„Åß„Åô': 'This is tough!',
            
            // Êó•Â∏∏‰ºöË©±
            '„ÅäËÖπ„Åå„Åô„ÅÑ„Åü': 'I\'m hungry',
            '„ÅÆ„Å©„Åå„Åã„Çè„ÅÑ„Å¶„ÅÑ„Åæ„Åô': 'I\'m thirsty',
            'Áúº„ÅåÁñ≤„Çå„Åæ„Åó„Åü': 'My eyes are tired',
            'È†≠„ÅåÁóõ„ÅÑ„Åß„Åô': 'I have a headache',
            'È¢®ÈÇ™„Çí„Å≤„ÅÑ„Åü„Åø„Åü„ÅÑ„Åß„Åô': 'I think I\'m coming down with something',
            'ÂÖÉÊ∞ó„Åå„Å™„ÅÑ„Åß„Åô': 'I\'m not feeling well',
            'Ê∞óÂàÜ„Åå„ÅÑ„ÅÑ„Åß„Åô': 'I feel great!',
            
            // „Éì„Ç∏„Éç„ÇπÁî®Ë™û
            '„ÅÑ„Åã„Åå„Åß„Åô„Åã': 'How does that sound?',
            'Ê§úË®é„Åó„Åæ„Åó„Çá„ÅÜ': 'Let\'s think about it',
            'Á¢∫Ë™ç„Åó„Åæ„Åô': 'I\'ll check on that',
            'ÈÄ£Áµ°„Åó„Åæ„Åô': 'I\'ll get back to you',
            'Êâì„Å°Âêà„Çè„Åõ„Åó„Åæ„Åó„Çá„ÅÜ': 'Let\'s have a meeting',
            'Ë≠∞Ë´ñ„Åó„Åæ„Åó„Çá„ÅÜ': 'Let\'s discuss this',
            'ÊèêÊ°à„Åó„Åæ„Åô': 'I\'d like to suggest...',
            'ÂêåÊÑè„Åó„Åæ„Åô': 'I agree',
            'ÂèçÂØæ„Åß„Åô': 'I disagree',
            'ÁêÜËß£„Åß„Åç„Åæ„Åõ„Çì': 'I don\'t get it',
            
            // ÊôÇÈñìË°®Áèæ
            '„ÇÇ„ÅÜ„Åô„Åê': 'in a moment',
            '„Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ': 'just a sec',
            'ÊÄ•„ÅÑ„Åß„ÅÑ„Åæ„Åô': 'I\'m in a hurry',
            'ÊôÇÈñì„Åå„ÅÇ„Çä„Åæ„Åõ„Çì': 'I don\'t have time',
            'ÊôÇÈñì„Åå„ÅÇ„ÇãÊôÇ„Å´': 'when you have time',
            '‰ªäÂ∫¶': 'next time',
            '‰ªäÂ∫¶„ÅÆÂúüÊõúÊó•': 'this Saturday',
            'Êù•ÈÄ±„ÅÆÁÅ´ÊõúÊó•': 'next Tuesday',
            
            // È£ü‰∫ãÈñ¢ÈÄ£
            '„ÅäËÖπ„ÅÑ„Å£„Å±„ÅÑ': 'I\'m stuffed',
            '„ÇÇ„ÅÜÂ∞ë„ÅóÈ£ü„Åπ„Åü„ÅÑ': 'I could eat a little more',
            '„Åô„Åî„Åè„Åä„ÅÑ„Åó„ÅÑ': 'This is delicious!',
            '„Å°„Çá„Å£„Å®Ëæõ„ÅÑ': 'It\'s a bit spicy',
            'Áîú„Åô„Åé„Åæ„Åô': 'It\'s too sweet',
            '„Åó„Çá„Å£„Å±„ÅÑ': 'It\'s salty',
            'ÁÜ±„Åô„Åé„Åæ„Åô': 'It\'s too hot',
            'ÂÜ∑„Åü„ÅÑ„Åß„Åô': 'It\'s cold',
            
            // Êñ∞„Åó„ÅÑÊÖ£Áî®Ë°®Áèæ
            '„ÇÑ„Å£„Å±„Çä': 'I knew it!',
            '„ÇÑ„Å£„Å®': 'finally',
            '„Åï„Åô„Åå': 'as expected',
            '„Åü„Åó„Åã„Å´': 'indeed',
            '„ÅÑ„Å§„ÅÆÈñì„Å´„Åã': 'before I knew it',
            '„Å™„Çì„Å®„Å™„Åè': 'somehow',
            '„ÇÇ„Åó„Åã„Åó„Å¶': 'maybe',
            '„ÇÇ„Åó„Åã„Åô„Çã„Å®': 'it could be that...'
        };
        
        // ÊñáËÑàÁêÜËß£Áî®„ÅÆ„Éë„Çø„Éº„É≥
        const contextPatterns = {
            // ÊôÇÂàª„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà
            'morning': ['Êúù', 'Êó©„ÅÑ', '„Åä„ÅØ„Çà„ÅÜ', 'Âá∫Âã§'],
            'afternoon': ['Êòº', 'ÂçàÂæå', '„É©„É≥„ÉÅ', 'Êò≠È£ü'],
            'evening': ['Â§ïÊñπ', 'Â§ú', '„Åì„Çì„Å∞„Çì', 'Â§ïÈ£ü', 'Â∏∞ÂÆÖ'],
            
            // ÊÑüÊÉÖ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà
            'positive': ['Â¨â„Åó„ÅÑ', 'Ê•Ω„Åó„ÅÑ', '„ÅÑ„ÅÑ', 'Á¥†Êô¥„Çâ„Åó„ÅÑ', 'ÊúÄÈ´ò'],
            'negative': ['ÊÇ≤„Åó„ÅÑ', '„Å§„Çâ„ÅÑ', 'Â´å„Å†', 'ÊúÄÊÇ™', '„Å†„ÇÅ'],
            
            // ‰ªï‰∫ã„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà
            'work': ['‰ºöÁ§æ', '‰ªï‰∫ã', '‰ºöË≠∞', '„Éó„É≠„Ç∏„Çß„ÇØ„Éà', '„Çø„Çπ„ÇØ'],
            'casual': ['ÂèãÈÅî', '„Ç≤„Éº„É†', 'Êº´Áîª', '„Ç¢„Éã„É°', 'Ë∂£Âë≥']
        };
        
        // Êó•Êú¨Ë™ûÁøªË®≥Áî®„ÅÆÂåÖÊã¨ÁöÑËæûÊõ∏„Å®ÊñáÊ≥ï„Éë„Çø„Éº„É≥  
        const translationDict = {
            // Âü∫Êú¨ÁöÑ„Å™Êå®Êã∂
            '„Åì„Çì„Å´„Å°„ÅØ': 'Hello',
            '„ÅÇ„Çä„Åå„Å®„ÅÜ': 'Thank you',
            '„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åó„Åü': 'Thank you very much',
            '„Åï„Çà„ÅÜ„Å™„Çâ': 'Goodbye',
            '„ÅØ„Åò„ÇÅ„Åæ„Åó„Å¶': 'Nice to meet you',
            '„Çà„Çç„Åó„Åè„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô': 'Please treat me favorably',
            '„Åä„ÅØ„Çà„ÅÜ': 'Good morning',
            '„Åä„ÅØ„Çà„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô': 'Good morning',
            '„Åì„Çì„Å∞„Çì„ÅØ': 'Good evening',
            '„Åä„ÇÑ„Åô„Åø': 'Good night',
            '„Åä„ÇÑ„Åô„Åø„Å™„Åï„ÅÑ': 'Good night',
            '„Åô„Åø„Åæ„Åõ„Çì': 'Excuse me / Sorry',
            '„Åî„ÇÅ„Çì„Å™„Åï„ÅÑ': 'I am sorry',
            'Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì': 'I apologize',
            '„ÅäÁñ≤„ÇåÊßò': 'Good work / Thank you for your hard work',
            '„ÅäÁñ≤„ÇåÊßò„Åß„Åó„Åü': 'Thank you for your hard work',
            '„ÅÑ„Çâ„Å£„Åó„ÇÉ„ÅÑ„Åæ„Åõ': 'Welcome',
            '„Å©„ÅÜ„ÅÑ„Åü„Åó„Åæ„Åó„Å¶': 'You are welcome',
            '„ÅäÂÖÉÊ∞ó„Åß„Åô„Åã': 'How are you?',
            'ÂÖÉÊ∞ó„Åß„Åô': 'I am fine',
            'Â§ß‰∏àÂ§´„Åß„Åô': 'I am okay / It is fine',
            '„Çè„Åã„Çä„Åæ„Åó„Åü': 'I understand',
            '„Çè„Åã„Çä„Åæ„Åõ„Çì': 'I do not understand',
            '„ÅØ„ÅÑ': 'Yes',
            '„ÅÑ„ÅÑ„Åà': 'No',
            '„Å°„Çá„Å£„Å®ÂæÖ„Å£„Å¶': 'Wait a moment',
            'Â∞ë„ÅóÂæÖ„Å£„Å¶„Åè„Å†„Åï„ÅÑ': 'Please wait a moment',
            
            // ÊôÇÈñì2Èñ¢ÈÄ£
            '‰ªäÊó•': 'today',
            'ÊòéÊó•': 'tomorrow',
            'Êò®Êó•': 'yesterday',
            '‰ªäÊúù': 'this morning',
            '‰ªäÂ§ú': 'tonight',
            'Êò®Â§ú': 'last night',
            'Êù•ÈÄ±': 'next week',
            'ÂÖàÈÄ±': 'last week',
            'Êù•Êúà': 'next month',
            'ÂÖàÊúà': 'last month',
            'Êù•Âπ¥': 'next year',
            'ÂéªÂπ¥': 'last year',
            '‰ªä': 'now',
            'Âæå„Åß': 'later',
            'Êó©„Åè': 'early',
            'ÈÅÖ„Åè': 'late',
            
            // ‰∫∫Áß∞‰ª£ÂêçË©û
            'ÁßÅ': 'I',
            '„ÅÇ„Å™„Åü': 'you',
            'ÂΩº': 'he',
            'ÂΩºÂ•≥': 'she',
            'ÁßÅ„Åü„Å°': 'we',
            '„ÅÇ„Å™„Åü„Åü„Å°': 'you all',
            'ÂΩº„Çâ': 'they',
            '„Åì„Çå': 'this',
            '„Åù„Çå': 'that',
            '„ÅÇ„Çå': 'that over there',
            '„Åì„Åì': 'here',
            '„Åù„Åì': 'there',
            '„ÅÇ„Åù„Åì': 'over there',
            '„Å©„Åì': 'where',
            '„ÅÑ„Å§': 'when',
            '‰Ωï': 'what',
            'Ë™∞': 'who',
            '„Å™„Åú': 'why',
            '„Å©„ÅÜ': 'how',
            
            // Âü∫Êú¨ÂãïË©û
            '„ÅÇ„Çã': 'exist / have',
            '„ÅÑ„Çã': 'exist (animate)',
            '„Åô„Çã': 'do',
            '„ÅÑ„Åè': 'go',
            '„Åè„Çã': 'come',
            'Â∏∞„Çã': 'return',
            'È£ü„Åπ„Çã': 'eat',
            'È£≤„ÇÄ': 'drink',
            'Ë¶ã„Çã': 'see / watch',
            'ËÅû„Åè': 'listen / hear',
            'Ë©±„Åô': 'speak',
            'Ë™≠„ÇÄ': 'read',
            'Êõ∏„Åè': 'write',
            'Â≠¶„Å∂': 'learn',
            'Êïô„Åà„Çã': 'teach',
            'ÂÉç„Åè': 'work',
            '‰ºë„ÇÄ': 'rest',
            'ÂØù„Çã': 'sleep',
            'Ëµ∑„Åç„Çã': 'wake up',
            'ÂÖ•„Çã': 'enter',
            'Âá∫„Çã': 'exit',
            '‰∏ä„Åå„Çã': 'go up',
            '‰∏ã„Åå„Çã': 'go down',
            'Ê≠¢„Åæ„Çã': 'stop',
            'Âßã„Åæ„Çã': 'start',
            'ÁµÇ„Çè„Çã': 'end',
            'ÊåÅ„Å§': 'hold',
            'ÁΩÆ„Åè': 'place',
            'Âèñ„Çã': 'take',
            '„ÅÇ„Åí„Çã': 'give',
            '„ÇÇ„Çâ„ÅÜ': 'receive',
            'Ë≤∑„ÅÜ': 'buy',
            'Â£≤„Çã': 'sell',
            '‰Ωú„Çã': 'make',
            '‰Ωø„ÅÜ': 'use',
            'Ê¥ó„ÅÜ': 'wash',
            'ÁùÄ„Çã': 'wear',
            'ËÑ±„Åê': 'take off',
            
            // ÂΩ¢ÂÆπË©û
            'Â§ß„Åç„ÅÑ': 'big',
            'Â∞è„Åï„ÅÑ': 'small',
            'È´ò„ÅÑ': 'tall / expensive',
            '‰Ωé„ÅÑ': 'short / cheap',
            'Êñ∞„Åó„ÅÑ': 'new',
            'Âè§„ÅÑ': 'old',
            'Ëã•„ÅÑ': 'young',
            'Áæé„Åó„ÅÑ': 'beautiful',
            '„Åç„Çâ„ÅÑ': 'clean',
            'Ê±ö„ÅÑ': 'dirty',
            'Êòé„Çã„ÅÑ': 'bright',
            'Êöó„ÅÑ': 'dark',
            'Ê∏©„Åã„ÅÑ': 'warm',
            'ÂÜ∑„Åü„ÅÑ': 'cold',
            'ÁÜ±„ÅÑ': 'hot',
            'Èù¢ÁôΩ„ÅÑ': 'interesting',
            '„Å§„Åæ„Çâ„Å™„ÅÑ': 'boring',
            'Ê•Ω„Åó„ÅÑ': 'fun',
            'ÊÇ≤„Åó„ÅÑ': 'sad',
            'Â¨â„Åó„ÅÑ': 'happy',
            'ÊÄñ„ÅÑ': 'scary',
            '„ÅÑ„Åü„ÅÑ': 'painful',
            '„Åä„ÅÑ„Åó„ÅÑ': 'delicious',
            '„Åæ„Åö„ÅÑ': 'bad tasting',
            'Èõ£„Åó„ÅÑ': 'difficult',
            'Á∞°Âçò': 'easy',
            'ÂÆâ„ÅÑ': 'cheap',
            'È´ò„ÅÑ': 'expensive',
            'ÈÅ†„ÅÑ': 'far',
            'Ëøë„ÅÑ': 'close',
            'Â§ö„ÅÑ': 'many',
            'Â∞ë„Å™„ÅÑ': 'few',
            'Â§ß‰∫ã': 'important',
            
            // Â†¥ÊâÄ„ÉªÂª∫Áâ©
            'ÂÆ∂': 'house / home',
            'Â≠¶Ê†°': 'school',
            '‰ºöÁ§æ': 'company',
            'ÁóÖÈô¢': 'hospital',
            '„É¨„Çπ„Éà„É©„É≥': 'restaurant',
            '„Ç≥„É≥„Éì„Éã': 'convenience store',
            '„Çπ„Éº„Éë„Éº': 'supermarket',
            'ÈßÖ': 'station',
            'Á©∫Ê∏Ø': 'airport',
            'ÂÖ¨Âúí': 'park',
            'Âõ≥Êõ∏È§®': 'library',
            'ÁæéË°ìÈ§®': 'art museum',
            'Êò†ÁîªÈ§®': 'movie theater',
            '„Éõ„ÉÜ„É´': 'hotel',
            'ÈäÄË°å': 'bank',
            'ÈÉµ‰æøÂ±Ä': 'post office',
            'Ë≠¶ÂØüÁΩ≤': 'police station',
            'Ê∂àÈò≤ÁΩ≤': 'fire station',
            'Â∏ÇÂΩπÊâÄ': 'city hall',
            
            // È£ü„ÅπÁâ©„ÉªÈ£≤„ÅøÁâ©
            '„ÅîÈ£Ø': 'rice / meal',
            '„Éë„É≥': 'bread',
            'ËÇâ': 'meat',
            'È≠ö': 'fish',
            'ÈáéËèú': 'vegetables',
            'ÊûúÁâ©': 'fruit',
            'Âçµ': 'egg',
            'Áâõ‰π≥': 'milk',
            'Ê∞¥': 'water',
            '„ÅäËå∂': 'tea',
            '„Ç≥„Éº„Éí„Éº': 'coffee',
            '„Ç∏„É•„Éº„Çπ': 'juice',
            '„Éì„Éº„É´': 'beer',
            '„ÉØ„Ç§„É≥': 'wine',
            'Êó•Êú¨ÈÖí': 'sake',
            '„ÅäÂºÅÂΩì': 'lunch box',
            '„Çµ„É©„ÉÄ': 'salad',
            '„Çπ„Éº„Éó': 'soup',
            '„É©„Éº„É°„É≥': 'ramen',
            '„Ç´„É¨„Éº': 'curry',
            '„Çπ„Ç∑': 'sushi',
            '„ÉÜ„É≥„Éó„É©': 'tempura',
            'ÁÑº„ÅçËÇâ': 'grilled meat',
            
            // ÂÆ∂Êóè„Éª‰∫∫Èñ¢‰øÇ
            'ÂÆ∂Êóè': 'family',
            '‰∏°Ë¶™': 'parents',
            'Áà∂': 'father',
            'ÊØç': 'mother',
            'ÂÖÑÂºü': 'brothers',
            'ÂßâÂ¶π': 'sisters',
            'Â≠ê‰æõ': 'child',
            'ÊÅØÂ≠ê': 'son',
            'Â®ò': 'daughter',
            'Á•ñÁà∂': 'grandfather',
            'Á•ñÊØç': 'grandmother',
            'ÂèãÈÅî': 'friend',
            'ÂÖàÁîü': 'teacher',
            'Â≠¶Áîü': 'student',
            'Á§æÂì°': 'employee',
            'Á§æÈï∑': 'company president',
            'ÈÉ®Èï∑': 'department manager',
            'ÂåªËÄÖ': 'doctor',
            'ÁúãË≠∑Â∏´': 'nurse',
            'Ë≠¶ÂØüÂÆò': 'police officer',
            'ÈÅãËª¢Êâã': 'driver',
            'Â∫óÂì°': 'store clerk',
            
            // Ë∫´‰ΩìÈÉ®‰Ωç
            'È†≠': 'head',
            'È´Æ': 'hair',
            'È°ç': 'forehead',
            'Áúº': 'eye',
            'Èºª': 'nose',
            'Âè£': 'mouth',
            'Ê≠Ø': 'tooth',
            'ËÄ≥': 'ear',
            'È¶ñ': 'neck',
            'ËÇ©': 'shoulder',
            'ËÖø': 'arm',
            'Êâã': 'hand',
            'Êåá': 'finger',
            'ËÉ∏': 'chest',
            'ËÉå‰∏≠': 'back',
            '„ÅäËÖπ': 'stomach',
            'Ë∂≥': 'leg / foot',
            'Ëá™Èñì': 'knee',
            'ÂøÉËáì': 'heart',
            'ËÖ∏': 'lung',
            
            // Ëâ≤
            'Ëµ§': 'red',
            'Èùí': 'blue',
            'ÈªÑËâ≤': 'yellow',
            'Á∑ë': 'green',
            'Èªí': 'black',
            'ÁôΩ': 'white',
            'ÁÅ∞Ëâ≤': 'gray',
            'Ëå∂Ëâ≤': 'brown',
            '„Éî„É≥„ÇØ': 'pink',
            'Á¥´': 'purple',
            '„Ç™„É¨„É≥„Ç∏': 'orange',
            
            // Êï∞Â≠ó
            'Èõ∂': 'zero',
            '‰∏Ä': 'one',
            '‰∫å': 'two',
            '‰∏â': 'three',
            'Âõõ': 'four',
            '‰∫î': 'five',
            'ÂÖ≠': 'six',
            '‰∏É': 'seven',
            'ÂÖ´': 'eight',
            '‰πù': 'nine',
            'ÂçÅ': 'ten',
            'Áôæ': 'hundred',
            'ÂçÉ': 'thousand',
            '‰∏á': 'ten thousand',
            
            // Â≠£ÁØÄ„ÉªÂ§©Ê∞ó
            'Êò•': 'spring',
            'Â§è': 'summer',
            'Áßã': 'autumn',
            'ÂÜ¨': 'winter',
            'Â§©Ê∞ó': 'weather',
            'Êô¥„Çå': 'sunny',
            'Èõ®': 'rain',
            'Èõ™': 'snow',
            'Êõá„Çä': 'cloudy',
            'È¢®': 'wind',
            'Âòâ': 'storm',
            'Ê∏©Â∫¶': 'temperature',
            
            // ‰∫§ÈÄöÊâãÊÆµ
            'Ëªä': 'car',
            'ÈõªËªä': 'train',
            '„Éê„Çπ': 'bus',
            '„Çø„ÇØ„Ç∑„Éº': 'taxi',
            'È£õË°åÊ©ü': 'airplane',
            'Ëá™Ëª¢Ëªä': 'bicycle',
            '„Éê„Ç§„ÇØ': 'motorcycle',
            'Âú∞‰∏ãÈâÑ': 'subway',
            'Êñ∞ÂππÁ∑ö': 'bullet train',
            'Ëàπ': 'ship',
            
            // ÊÑüÊÉÖË°®Áèæ
            'Â¨â„Åó„ÅÑ': 'happy',
            'ÊÇ≤„Åó„ÅÑ': 'sad',
            'ÊÄí„Å£„Å¶„ÅÑ„Çã': 'angry',
            'È©ö„ÅÑ„Å¶„ÅÑ„Çã': 'surprised',
            'ÂøÉÈÖç': 'worried',
            'ÂÆâÂøÉ': 'relieved',
            'Áñë„Å£„Å¶„ÅÑ„Çã': 'confused',
            'ÊúüÂæÖ„Åó„Å¶„ÅÑ„Çã': 'excited',
            'Áñ≤„Çå„Å¶„ÅÑ„Çã': 'tired',
            'ÂÖÉÊ∞ó': 'energetic',
            
            // „Éì„Ç∏„Éç„ÇπÁî®Ë™û
            '‰ºöË≠∞': 'meeting',
            '„Éó„É¨„Çº„É≥„ÉÜ„Éº„Ç∑„Éß„É≥': 'presentation',
            'Â†±Âëä': 'report',
            'Ë≥áÊñô': 'materials',
            '„Çπ„Ç±„Ç∏„É•„Éº„É´': 'schedule',
            'Á∑†„ÇÅÂàá„Çä': 'deadline',
            '„Éó„É≠„Ç∏„Çß„ÇØ„Éà': 'project',
            '„ÉÅ„Éº„É†': 'team',
            'ÈÉ®ÈñÄ': 'department',
            '‰ºÅÊ•≠': 'company',
            'È°ßÂÆ¢': 'customer',
            'Â•ëÁ¥Ñ': 'contract',
            '‰∫§Ê∏â': 'negotiation',
            'ÁµêÊûú': 'result',
            'ÊàêÊûú': 'achievement'
        };
        
        // ÊñáÊ≥ï„Éë„Çø„Éº„É≥„ÅÆÁøªË®≥„É´„Éº„É´
        const grammarPatterns = [
            { pattern: /(.+)„Åß„Åô$/, replacement: '$1' },
            { pattern: /(.+)„Åß„Åó„Åü$/, replacement: '$1 was' },
            { pattern: /(.+)„Åæ„Åô$/, replacement: '$1' },
            { pattern: /(.+)„Åæ„Åó„Åü$/, replacement: '$1 ed' },
            { pattern: /(.+)„Åó„Åü$/, replacement: '$1 did' },
            { pattern: /(.+)„Åó„Å¶„ÅÑ„Åæ„Åô$/, replacement: '$1 ing' },
            { pattern: /(.+)„Åó„Å¶„ÅÑ„Åæ„Åó„Åü$/, replacement: '$1 was ing' },
            { pattern: /(.+)„Åã„Çâ$/, replacement: 'from $1' },
            { pattern: /(.+)„Åæ„Åß$/, replacement: 'until $1' },
            { pattern: /(.+)„Å®$/, replacement: 'with $1' },
            { pattern: /(.+)„Å´$/, replacement: 'to $1' },
            { pattern: /(.+)„Åß$/, replacement: 'at $1' },
            { pattern: /(.+)„Åå$/, replacement: '$1 is' },
            { pattern: /(.+)„Çí$/, replacement: '$1 (object)' },
            { pattern: /„Å©„ÅÜ„Åß„Åô„Åã/, replacement: 'how is it?' },
            { pattern: /„Å©„Åì„Åß„Åô„Åã/, replacement: 'where is it?' },
            { pattern: /„ÅÑ„Å§„Åß„Åô„Åã/, replacement: 'when is it?' },
            { pattern: /‰Ωï„Åß„Åô„Åã/, replacement: 'what is it?' },
            { pattern: /Ë™∞„Åß„Åô„Åã/, replacement: 'who is it?' },
            { pattern: /„Å™„Åú„Åß„Åô„Åã/, replacement: 'why is it?' }
        ];

        function initializeSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                updateStatus('Speech recognition is not supported');
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();

            // Êó•Êú¨Ë™ûË™çË≠ò„ÅÆÁ≤æÂ∫¶Âêë‰∏äË®≠ÂÆö
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 3; // Ë§áÊï∞„ÅÆÂÄôË£ú„ÇíÂèñÂæó
            recognition.lang = document.getElementById('languageSelect').value;
            
            // Èü≥Â£∞Ë™çË≠ò„ÅÆÂìÅË≥™Âêë‰∏ä
            if (recognition.serviceURI) {
                recognition.serviceURI = 'wss://www.google.com/speech-api/full-duplex/v1/up';
            }

            recognition.onstart = () => {
                isRecognizing = true;
                recognitionIsActive = true;
                recognitionStartPending = false;
                resetRecognitionRestartBackoff();
                updateStatus('üé§ Listening...');
                document.getElementById('recordingIndicator').style.display = 'block';

                const startBtn = document.getElementById('startButton');
                const stopBtn = document.getElementById('stopButton');
                if (startBtn) startBtn.disabled = true;
                if (stopBtn) stopBtn.disabled = false;
            };

            recognition.onerror = (event) => {
                console.error('Èü≥Â£∞Ë™çË≠ò„Ç®„É©„Éº:', event.error);

                // stop() „Å´„Çà„Çã‰∏≠Êñ≠„ÅØÊÉ≥ÂÆöÂÜÖ
                if (event.error === 'aborted') {
                    return;
                }

                // ÁÑ°Èü≥„ÅåÁ∂ö„Åè„Å®Áô∫Áîü„Åó„ÇÑ„Åô„ÅÑ„ÄÇ„Åì„Åì„ÅßÂÜçÈñã start() „ÇíÈáç„Å≠„Çã„Å® InvalidState „Å´„Å™„Çä„ÇÑ„Åô„ÅÑ
                if (event.error === 'no-speech') {
                    updateStatus('‚Ä¶waiting (silence)‚Ä¶');
                    return;
                }

                updateStatus(`‚ùå Error: ${event.error}`);
                document.getElementById('recordingIndicator').style.display = 'none';

                // Ê®©ÈôêÁ≥ª„Ç®„É©„Éº„ÅØËá™ÂãïÂÜçË©¶Ë°å„Åô„Çã„Å®Ë®±ÂèØ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåÁπ∞„ÇäËøî„ÅóÂá∫„ÇÑ„Åô„ÅÑ„ÅÆ„ÅßÂÅúÊ≠¢
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    isRecognizing = false;
                    autoStarted = false;
                    recognitionIsActive = false;
                    recognitionStartPending = false;
                    updateStatus('‚ùå Microphone permission is required (check your browser site settings)');
                    return;
                }

                // „Åù„ÅÆ‰ªñ„ÅÆ‰∏ÄÊôÇÁöÑ„Ç®„É©„Éº„ÅØ getUserMedia „Åõ„Åö„Å´Ë™çË≠ò„ÅÆ„ÅøÂÜçÈñã
                scheduleRecognitionRestart(event.error);
            };

            recognition.onend = () => {
                document.getElementById('recordingIndicator').style.display = 'none';
                recognitionIsActive = false;
                recognitionStartPending = false;

                if (isRecognizing && document.getElementById('continuousMode').checked) {
                    // onerror „Åß„ÇÇ onend „Åß„ÇÇ„ÄåÂêå„ÅòÂÜçÈñã„É´„Éº„Éà„Äç„Å´Áµ±‰∏Ä„Åó„Å¶‰∫åÈáç start „ÇíÈò≤„Åê
                    scheduleRecognitionRestart('onend');
                    return;
                }

                resetRecognition();
            };

            recognition.onresult = async (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                let bestConfidence = 0;
                let bestTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    
                    // AI„Çâ„Åó„ÅÑÂÄôË£úÈÅ∏Êäû„Ç¢„É´„Ç¥„É™„Ç∫„É†
                    let selectedTranscript = selectBestCandidate(result);
                    let selectedConfidence = result[0].confidence || 0;
                    
                    if (result.isFinal) {
                        // Êó•Êú¨Ë™û„ÅÆÊñáÁØÄ„ÇíÊï¥ÂΩ¢
                        selectedTranscript = cleanJapaneseText(selectedTranscript);
                        
                        // Â≠¶ÁøíÊ©üËÉΩ: „É¶„Éº„Ç∂„Éº„ÅÆË™ûÂΩô„ÇíÂ≠¶Áøí
                        learnUserVocabulary(selectedTranscript, selectedConfidence);
                        
                        // Â≠¶ÁøíÊ©üËÉΩ: Èü≥Â£∞„Éë„Çø„Éº„É≥„ÇíÂ≠¶Áøí
                        learnSpeechPatterns(selectedTranscript);
                        
                        finalTranscript += selectedTranscript;
                        
                        if (selectedConfidence > bestConfidence) {
                            bestConfidence = selectedConfidence;
                            bestTranscript = selectedTranscript;
                        }
                    } else {
                        interimTranscript += selectedTranscript;
                    }
                }

                currentTranscript = finalTranscript || interimTranscript;
                
                if (currentTranscript.trim()) {
                    // Êó•Êú¨Ë™û„ÅÆÁâπÊÆäÂá¶ÁêÜ„Å®Â≠¶ÁøíÊ©üËÉΩÈÅ©Áî®
                    const processedTranscript = processJapaneseTranscript(currentTranscript.trim());
                    await displaySubtitles(processedTranscript, !finalTranscript, bestConfidence || 0.5);
                    lastSpeechTime = Date.now();
                }
            };

            return true;
        }

        // AI„Çâ„Åó„ÅÑÂ≠¶ÁøíÊ©üËÉΩÈñ¢Êï∞Áæ§
        
        // ÊúÄÈÅ©„Å™ÂÄôË£ú„ÇíÈÅ∏Êäû„Åô„ÇãAI„Ç¢„É´„Ç¥„É™„Ç∫„É†
        function selectBestCandidate(result) {
            if (result.length === 1) {
                return result[0].transcript;
            }
            
            let bestScore = 0;
            let bestTranscript = result[0].transcript;
            
            for (let j = 0; j < Math.min(result.length, 3); j++) {
                const candidate = result[j];
                const confidence = candidate.confidence || 0;
                const transcript = candidate.transcript;
                
                let score = confidence;
                
                // Êó•Êú¨Ë™û„Çâ„Åó„Åï„Çπ„Ç≥„Ç¢
                const japaneseScore = /[„ÅÇ-„Çñ„Ç¢-„É∂‰∏Ä-ÈæØ]/.test(transcript) ? 0.15 : 0;
                score += japaneseScore;
                
                // „É¶„Éº„Ç∂„Éº„ÅÆÂ≠¶ÁøíÊ∏à„ÅøË™ûÂΩô„Çπ„Ç≥„Ç¢
                const vocabularyScore = calculateVocabularyScore(transcript);
                score += vocabularyScore;
                
                // ÊñáËÑà„Çπ„Ç≥„Ç¢
                const contextScore = calculateContextScore(transcript);
                score += contextScore;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestTranscript = transcript;
                }
            }
            
            return bestTranscript;
        }
        
        // „É¶„Éº„Ç∂„Éº„ÅÆË™ûÂΩô„ÇíÂ≠¶Áøí
        function learnUserVocabulary(text, confidence) {
            const words = text.split(/[„ÄÄ\s„ÄÅ„ÄÇ„Äå„Äç]+/).filter(word => word.length > 0);
            
            words.forEach(word => {
                if (userVocabulary.has(word)) {
                    const existing = userVocabulary.get(word);
                    userVocabulary.set(word, {
                        count: existing.count + 1,
                        totalConfidence: existing.totalConfidence + confidence,
                        avgConfidence: (existing.totalConfidence + confidence) / (existing.count + 1),
                        lastUsed: Date.now()
                    });
                } else {
                    userVocabulary.set(word, {
                        count: 1,
                        totalConfidence: confidence,
                        avgConfidence: confidence,
                        lastUsed: Date.now()
                    });
                }
            });
            
            // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò
            localStorage.setItem('userVocabulary', JSON.stringify(Array.from(userVocabulary.entries())));
        }
        
        // Èü≥Â£∞„Éë„Çø„Éº„É≥„ÇíÂ≠¶Áøí
        function learnSpeechPatterns(text) {
            // n-gram„Éë„Çø„Éº„É≥„ÇíÂ≠¶ÁøíÔºà2-gram, 3-gramÔºâ
            const patterns = extractNGrams(text, 2).concat(extractNGrams(text, 3));
            
            patterns.forEach(pattern => {
                if (speechPatterns.has(pattern)) {
                    speechPatterns.set(pattern, speechPatterns.get(pattern) + 1);
                } else {
                    speechPatterns.set(pattern, 1);
                }
            });
            
            // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò
            localStorage.setItem('speechPatterns', JSON.stringify(Array.from(speechPatterns.entries())));
        }
        
        // N-gram„Éë„Çø„Éº„É≥„ÇíÊäΩÂá∫
        function extractNGrams(text, n) {
            const grams = [];
            for (let i = 0; i <= text.length - n; i++) {
                grams.push(text.substring(i, i + n));
            }
            return grams;
        }
        
        // Ë™ûÂΩô„Çπ„Ç≥„Ç¢„ÇíË®àÁÆó
        function calculateVocabularyScore(text) {
            const words = text.split(/[„ÄÄ\s„ÄÅ„ÄÇ„Äå„Äç]+/).filter(word => word.length > 0);
            let score = 0;
            
            words.forEach(word => {
                if (userVocabulary.has(word)) {
                    const vocab = userVocabulary.get(word);
                    // ‰ΩøÁî®È†ªÂ∫¶„Å®‰ø°È†ºÂ∫¶„Å´Âü∫„Å•„ÅÑ„Å¶„Çπ„Ç≥„Ç¢ÁÆóÂá∫
                    score += Math.min(vocab.count * 0.01, 0.1) + vocab.avgConfidence * 0.05;
                }
            });
            
            return score;
        }
        
        // ÊñáËÑà„Çπ„Ç≥„Ç¢„ÇíË®àÁÆó
        function calculateContextScore(text) {
            let score = 0;
            
            // ÊñáËÑà„Éë„Çø„Éº„É≥„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            for (const [context, keywords] of Object.entries(contextPatterns)) {
                keywords.forEach(keyword => {
                    if (text.includes(keyword)) {
                        score += 0.05;
                    }
                });
            }
            
            return score;
        }
        
        // Â≠¶Áøí„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø
        function loadLearningData() {
            try {
                const vocabData = localStorage.getItem('userVocabulary');
                if (vocabData) {
                    userVocabulary = new Map(JSON.parse(vocabData));
                }
                
                const patternData = localStorage.getItem('speechPatterns');
                if (patternData) {
                    speechPatterns = new Map(JSON.parse(patternData));
                }
                
                console.log(`Â≠¶ÁøíÊ∏à„ÅøË™ûÂΩô: ${userVocabulary.size}ÂÄã, „Éë„Çø„Éº„É≥: ${speechPatterns.size}ÂÄã`);
            } catch (error) {
                console.error('Â≠¶Áøí„Éá„Éº„ÇøË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
            }
        }

        // Ëá™Âãï„ÅßÈü≥Â£∞Ë™çË≠ò„ÇíÈñãÂßã„Åô„ÇãÈñ¢Êï∞
        async function autoStartRecognition() {
            if (autoStarted) return;

            // ÂàùÂõûË®™Âïè„Åß„ÅÆËá™ÂãïË®±ÂèØË¶ÅÊ±Ç„ÇíÈÅø„Åë„ÇãÔºàË®±ÂèØÊ∏à„Åø„ÅÆÂÜçË®™„ÅÆ„ÅøËá™ÂãïÈñãÂßãÔºâ
            if (localStorage.getItem(MIC_PERMISSION_CACHE_KEY) !== 'true') {
                return;
            }
            
            const micReady = await getSelectedMicrophone(false);
            if (!micReady) {
                // Ëá™ÂãïÂá¶ÁêÜ„Åß„ÅÆÂÜçË©¶Ë°å„É´„Éº„Éó„ÅØË®±ÂèØ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆÂéüÂõ†„Å´„Å™„Çä„ÇÑ„Åô„ÅÑ„ÅÆ„ÅßÂÅúÊ≠¢
                return;
            }

            if (!recognition && !initializeSpeechRecognition()) {
                return;
            }

            recognition.lang = document.getElementById('languageSelect').value;
            
            try {
                if (recognitionIsActive || recognitionStartPending) {
                    return;
                }

                recognitionStartPending = true;
                recognition.start();
                autoStarted = true;
                updateStatus('üé§ Speech recognition auto-started');
            } catch (e) {
                console.error('Ëá™ÂãïÈñãÂßã„Ç®„É©„Éº:', e);
                recognitionStartPending = false;
            }
        }

        // Êó•Êú¨Ë™û„ÉÜ„Ç≠„Çπ„Éà„ÇíÊï¥ÂΩ¢„Åô„ÇãÈñ¢Êï∞
        function cleanJapaneseText(text) {
            // ‰∏çË¶Å„Å™Á©∫ÁôΩ„ÇíÈô§Âéª
            text = text.replace(/\s+/g, '');
            
            // Êï∞Â≠ó„ÅÆÊ≠£Ë¶èÂåñ
            text = text.replace(/„ÄÅ/g, '„ÄÅ ');
            text = text.replace(/„ÄÇ/g, '„ÄÇ ');
            
            // ÈÄ£Á∂ö„Åô„ÇãÂè•Ë™≠ÁÇπ„ÇíÊï¥ÁêÜ
            text = text.replace(/[„ÄÅ„ÄÇ]+/g, (match) => match[0]);
            
            return text.trim();
        }
        
        // Êó•Êú¨Ë™û„ÉÜ„Ç≠„Çπ„Éà„ÅÆÁâπÊÆäÂá¶ÁêÜ
        function processJapaneseTranscript(text) {
            // „Å≤„Çâ„Åå„Å™„ÅÆÊ≠£Ë¶èÂåñ
            text = text.replace(/„Çì„Åß„Åô/g, '„Åß„Åô');
            text = text.replace(/„Çì„Åß„Åó„Åü/g, '„Åß„Åó„Åü');
            
            // Ëã±Ë™ûÂçòË™û„ÅÆÊ≠£Ë¶èÂåñ
            text = text.replace(/[A-Za-z]+/g, (match) => {
                // Ëã±ÂçòË™û„ÅØ„Åù„ÅÆ„Åæ„Åæ‰øùÊåÅ
                return match;
            });
            
            return text;
        }
        
        // „Éç„Ç§„ÉÜ„Ç£„Éñ„Çπ„Éî„Éº„Ç´„ÉºÈ¢®„ÅÆÊÑèË®≥Èñ¢Êï∞ÔºàÊîπËâØÁâàÔºâ
        function translateJapaneseToEnglish(text) {
            let translation = text;
            let hasTranslation = false;
            
            // 1. „Éç„Ç§„ÉÜ„Ç£„ÉñË°®Áèæ„ÇíÂÑ™ÂÖàÈÅ©Áî®
            for (const [japanese, nativeEnglish] of Object.entries(nativeExpressions)) {
                if (translation.includes(japanese)) {
                    translation = translation.replace(new RegExp(japanese, 'g'), nativeEnglish);
                    hasTranslation = true;
                }
            }
            
            // 2. ÊñáËÑà„ÇíËÄÉÊÖÆ„Åó„ÅüÁøªË®≥
            const context = determineContext(text);
            translation = applyContextualTranslation(translation, context);
            
            // 3. Âü∫Êú¨ËæûÊõ∏ÁøªË®≥ÔºàÊÑèË®≥ÈáçË¶ñÔºâ
            for (const [japanese, english] of Object.entries(translationDict)) {
                if (translation.includes(japanese)) {
                    const contextualEnglish = getContextualTranslation(japanese, english, context);
                    translation = translation.replace(new RegExp(japanese.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), contextualEnglish);
                    hasTranslation = true;
                }
            }
            
            // 4. ÊñáÊ≥ï„Éë„Çø„Éº„É≥„ÅÆÊÑèË®≥ÈÅ©Áî®
            translation = applyNativeGrammarPatterns(translation, context);

            // 4.5. Âü∫Êú¨ÁöÑ„Å™ÊñáÊßãÈÄ†„Éë„Çø„Éº„É≥„ÇÇÈÅ©Áî®Ôºà„Ç™„Éï„É©„Ç§„É≥ÁøªË®≥„ÅÆÂ∫ï‰∏ä„ÅíÔºâ
            translation = basicJapaneseTranslation(translation);
            
            // 5. Êú™Áü•Ë™û„ÅÆÂá¶ÁêÜ
            translation = translateUnknownWords(translation);
            
            // 6. ÊúÄÁµÇÁöÑ„Å™„Éç„Ç§„ÉÜ„Ç£„ÉñÈ¢®Êï¥ÂΩ¢
            translation = finalizeNativeTranslation(translation, text, context, hasTranslation);
                
            // 7. ÁøªË®≥Â±•Ê≠¥„Å∏Ë®òÈå≤
            recordTranslationHistory(text, translation, context);

            // 8. Ëã±Ë™ûÂ≠óÂπïÂÅ¥„Å´Êó•Êú¨Ë™û„ÅåÊÆã„Çâ„Å™„ÅÑ„Çà„ÅÜÊúÄÁµÇ„Çµ„Éã„Çø„Ç§„Ç∫
            translation = sanitizeEnglishSubtitle(translation, text);

            return translation;
        }

        function sanitizeEnglishSubtitle(candidate, originalText) {
            let t = (candidate || '').toString();

            // "..." (Japanese) „ÅÆ„Çà„ÅÜ„Å™„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÅØËã±Ë™ûÂ≠óÂπï„Å®„Åó„Å¶„ÅØÊó•Êú¨Ë™û„ÅåÊÆã„Çã„Åü„ÇÅÈô§Âéª
            t = t.replace(/"[^"]*"\s*\(Japanese\)/g, '').trim();
            t = t.replace(/\(Japanese\)/g, '').trim();

            // Ë®òÂè∑È°û„ÅÆÊï¥ÁêÜ
            t = t.replace(/[„ÄÅ„ÄÇ„Éª„Äå„Äç„Äé„Äè„Äê„Äë]/g, ' ');
            t = t.replace(/\s+/g, ' ').trim();

            // „Åæ„Å†Êó•Êú¨Ë™û„ÅåÊÆã„ÇãÂ†¥Âêà„ÅØ„ÄÅËã±Ë™ûÂ≠óÂπïÂÅ¥„Åã„Çâ„ÅØÈô§ÂéªÔºàÊó•Êú¨Ë™ûË°®Á§∫„ÇíÈÅø„Åë„ÇãÔºâ
            if (/[„ÅÅ-„Çñ„Ç°-„É∂‰∏Ä-ÈæØ]/.test(t)) {
                t = t.replace(/[„ÅÅ-„Çñ„Ç°-„É∂‰∏Ä-ÈæØ]+/g, ' ');
                t = t.replace(/\s+/g, ' ').trim();
            }

            // ‰Ωï„ÇÇÊÆã„Çâ„Å™„Åë„Çå„Å∞Á∞°ÊΩî„Å™„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
            if (!t) {
                return '(untranslated)';
            }

            return t;
        }
        
        // ÊñáËÑà„ÇíÂà§ÂÆö
        function determineContext(text) {
            const contexts = [];
            
            // ÊôÇÈñì5„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà
            const hour = new Date().getHours();
            if (hour < 11) contexts.push('morning');
            else if (hour < 17) contexts.push('afternoon');
            else contexts.push('evening');
            
            // ÂÜÖÂÆπ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà
            for (const [contextType, keywords] of Object.entries(contextPatterns)) {
                if (keywords.some(keyword => text.includes(keyword))) {
                    contexts.push(contextType);
                }
            }
            
            return contexts;
        }
        
        // ÊñáËÑà„Å´Âøú„Åò„ÅüÁøªË®≥„ÇíÈÅ©Áî®
        function applyContextualTranslation(text, contexts) {
            // ÊñáËÑà„Å´Âøú„Åò„ÅüÁâπÊÆä„Å™ÁøªË®≥„É´„Éº„É´
            const contextualRules = {
                'morning': {
                    '„Åä„ÅØ„Çà„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô': 'Good morning!',
                    '‰ªäÊó•„ÇÇ': 'Today again',
                    'Êó©„ÅÑ': 'early'
                },
                'evening': {
                    '„Åì„Çì„Å∞„Çì„ÅØ': 'Good evening!',
                    '„ÅäÁñ≤„ÇåÊßò': 'You must be tired',
                    'ÈÅÖ„ÅÑ': 'late'
                },
                'work': {
                    'È†ëÂºµ„Çä„Åæ„Åô': 'I\'ll do my best',
                    'ÁµÇ„Çè„Çä„Åæ„Åó„Åü': 'I\'m done',
                    'Á¢∫Ë™ç„Åó„Åæ„Åô': 'I\'ll check'
                },
                'casual': {
                    'Èù¢ÁôΩ„ÅÑ': 'That\'s cool!',
                    '„Åô„Åî„ÅÑ': 'Awesome!',
                    '„ÇÑ„Å∞„ÅÑ': 'Oh no!'
                }
            };
            
            let result = text;
            contexts.forEach(context => {
                const rules = contextualRules[context];
                if (rules) {
                    for (const [jp, en] of Object.entries(rules)) {
                        result = result.replace(new RegExp(jp, 'g'), en);
                    }
                }
            });
            
            return result;
        }
        
        // ÊñáËÑà„Å´Âøú„Åò„ÅüË™ûÂΩôÁøªË®≥
        function getContextualTranslation(japanese, defaultEnglish, contexts) {
            // ÊñáËÑà„Å´Âøú„Åò„Å¶„Çà„ÇäËá™ÁÑ∂„Å™ÁøªË®≥„ÇíÈÅ∏Êäû
            const contextualDict = {
                'Â§ß‰∏àÂ§´': {
                    'work': 'It\'s fine',
                    'casual': 'No worries',
                    'default': 'It\'s okay'
                },
                '„ÅÇ„Çä„Åå„Å®„ÅÜ': {
                    'work': 'Thank you',
                    'casual': 'Thanks!',
                    'evening': 'Thanks for today'
                },
                '„Åô„Åø„Åæ„Åõ„Çì': {
                    'work': 'I apologize',
                    'casual': 'Sorry!',
                    'default': 'Excuse me'
                }
            };
            
            if (contextualDict[japanese]) {
                const options = contextualDict[japanese];
                
                // ÊñáËÑà„Å´„Éû„ÉÉ„ÉÅ„Åô„ÇãÁøªË®≥„ÇíÊé¢„Åô
                for (const context of contexts) {
                    if (options[context]) {
                        return options[context];
                    }
                }
                
                return options.default || defaultEnglish;
            }
            
            return defaultEnglish;
        }
        
        // „Éç„Ç§„ÉÜ„Ç£„ÉñÊñáÊ≥ï„Éë„Çø„Éº„É≥„ÇíÈÅ©Áî®
        function applyNativeGrammarPatterns(text, contexts) {
            const nativePatterns = [
                // „Çà„ÇäËá™ÁÑ∂„Å™Ëã±Ë™ûË°®Áèæ„Å´Â§âÊèõ
                { pattern: /(.+)„ÅåÂ•Ω„Åç„Åß„Åô/, replacement: 'I love $1', contexts: ['casual'] },
                { pattern: /(.+)„ÅåÂ•Ω„Åç„Åß„Åô/, replacement: 'I like $1', contexts: ['work'] },
                { pattern: /(.+)„ÇíÈ£ü„Åπ„Åæ„Åó„Åü/, replacement: 'I had $1', contexts: ['casual'] },
                { pattern: /(.+)„ÇíÈ£ü„Åπ„Åæ„Åó„Åü/, replacement: 'I ate $1', contexts: ['work'] },
                { pattern: /(.+)„Å´Ë°å„Åç„Åæ„Åó„Åü/, replacement: 'I went to $1' },
                { pattern: /(.+)„Åó„Åü„ÅÑ„Åß„Åô/, replacement: 'I\'d like to $1' },
                { pattern: /(.+)„Åå„ÅÑ„ÅÑ„Åß„Åô„Å≠/, replacement: '$1 is nice!', contexts: ['casual'] },
                { pattern: /(.+)„Åå„ÅÑ„ÅÑ„Åß„Åô„Å≠/, replacement: '$1 would be good', contexts: ['work'] },
                { pattern: /(.+)„Åß„Åç„Åæ„Åô„Åã/, replacement: 'Can you $1?' },
                { pattern: /(.+)„Å™„Çì„Åß„Åô„Åã/, replacement: 'What\'s $1?' },
                { pattern: /(.+)„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì/, replacement: '$1 might be...' },
                { pattern: /(.+)„ÅØ„Å©„ÅÜ„Åß„Åô„Åã/, replacement: 'How about $1?' },
                { pattern: /(.+)„Å†„Å®ÊÄù„ÅÑ„Åæ„Åô/, replacement: 'I think it\'s $1' },
                { pattern: /(.+)„Åã„Çâ(.+)„Åß„Åô/, replacement: 'It\'s $2 because of $1' },
                { pattern: /„Åù„ÅÜ„Åß„Åô„Å≠/, replacement: 'Exactly!' },
                { pattern: /„Å©„ÅÜ„Åó„Çà„ÅÜ/, replacement: 'What should I do?' },
                { pattern: /„Åù„Çì„Å™„Åì„Å®„Å™„ÅÑ„Åß„Åô/, replacement: 'That\'s not true' },
                { pattern: /„Åæ„Åï„Åã/, replacement: 'No way!' },
                { pattern: /„ÇÑ„Å£„Å±„Çä/, replacement: 'I knew it!' }
            ];
            
            let result = text;
            
            for (const rule of nativePatterns) {
                if (rule.contexts && !rule.contexts.some(ctx => contexts.includes(ctx))) {
                    continue; // ÊñáËÑà„Åå„Éû„ÉÉ„ÉÅ„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                }
                
                if (rule.pattern.test(result)) {
                    result = result.replace(rule.pattern, rule.replacement);
                    break; // ÊúÄÂàù„ÅÆ„Éû„ÉÉ„ÉÅ„ÅßÂÅúÊ≠¢
                }
            }
            
            return result;
        }
        
        // ÊúÄÁµÇÁöÑ„Å™„Éç„Ç§„ÉÜ„Ç£„ÉñÈ¢®Êï¥ÂΩ¢
        function finalizeNativeTranslation(translation, originalText, contexts, hasTranslation) {
            // 1. Á∏ÆÁ¥ÑÂΩ¢„ÇÑÂè£Ë™ûÁöÑË°®Áèæ„ÇíËøΩÂä†
            translation = translation
                .replace(/I am /g, "I'm ")
                .replace(/You are /g, "You're ")
                .replace(/It is /g, "It's ")
                .replace(/That is /g, "That's ")
                .replace(/I will /g, "I'll ")
                .replace(/I would /g, "I'd ")
                .replace(/cannot /g, "can't ")
                .replace(/do not /g, "don't ")
                .replace(/does not /g, "doesn't ");
            
            // 2. „Ç´„Ç∏„É•„Ç¢„É´„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Åß„ÅÆË°®ÁèæË™øÊï¥
            if (contexts.includes('casual')) {
                translation = translation
                    .replace(/very /g, 'really ')
                    .replace(/excellent/g, 'awesome')
                    .replace(/wonderful/g, 'great')
                    .replace(/terrible/g, 'awful');
            }
            
            // 3. ÊúÄÁµÇÊï¥ÂΩ¢
            translation = translation
                .replace(/\s+/g, ' ')
                .trim();
                
            // ÊúÄÂàù„ÅÆÊñáÂ≠ó„ÇíÂ§ßÊñáÂ≠ó„Å´
            if (translation) {
                translation = translation.charAt(0).toUpperCase() + translation.slice(1);
            }
            
            // ÁøªË®≥„Åß„Åç„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅÆÂá¶ÁêÜ
            if (!hasTranslation && translation === originalText) {
                const phoneticTranslation = createPhoneticTranslation(originalText);
                if (phoneticTranslation !== originalText) {
                    return phoneticTranslation;
                }
                return `"${originalText}" (Japanese)`;
            }
            
            return translation || `"${originalText}"`;
        }
        
        // ÁøªË®≥Â±•Ê≠¥„ÇíË®òÈå≤
        function recordTranslationHistory(original, translated, contexts) {
            translationHistory.push({
                original,
                translated,
                contexts,
                timestamp: Date.now()
            });
            
            // Â±•Ê≠¥„Åå100‰ª∂„ÇíË∂Ö„Åà„Åü„ÇâÂè§„ÅÑ„ÇÇ„ÅÆ„ÇíÂâäÈô§
            if (translationHistory.length > 100) {
                translationHistory.shift();
            }
            
            // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò
            localStorage.setItem('translationHistory', JSON.stringify(translationHistory));
        }
        
        // Êú™Áü•„ÅÆÂçòË™û„ÇíÂá¶ÁêÜ„Åô„ÇãÈñ¢Êï∞
        function translateUnknownWords(text) {
            let result = text;
            
            // „Ç´„Çø„Ç´„ÉäÂ§ñÊù•Ë™û„ÅÆÂá¶ÁêÜ
            result = result.replace(/[„Ç¢-„É∂„Éº]+/g, (match) => {
                // „Ç´„Çø„Ç´„Éä„ÅØ„Åù„ÅÆ„Åæ„ÅæËã±Ë™û„Å®„Åó„Å¶Êâ±„ÅÜ„Åì„Å®„ÅåÂ§ö„ÅÑ
                return convertKatakanaToEnglish(match);
            });
            
            // Êï∞Â≠ó„ÅÆÂá¶ÁêÜ
            result = result.replace(/[‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅÁôæÂçÉ‰∏á]+/g, (match) => {
                return convertJapaneseNumbers(match);
            });
            
            return result;
        }
        
        // „Ç´„Çø„Ç´„Éä„ÇíËã±Ë™û„Å´Â§âÊèõ
        function convertKatakanaToEnglish(katakana) {
            const katakanaToEnglish = {
                '„Ç≥„É≥„Éî„É•„Éº„Çø„Éº': 'computer',
                '„Ç§„É≥„Çø„Éº„Éç„ÉÉ„Éà': 'internet',
                '„Çπ„Éû„Éº„Éà„Éï„Ç©„É≥': 'smartphone',
                '„Ç¢„Éó„É™': 'app',
                '„Ç≤„Éº„É†': 'game',
                '„Éü„É•„Éº„Ç∏„ÉÉ„ÇØ': 'music',
                '„Éì„Éá„Ç™': 'video',
                '„ÉÜ„É¨„Éì': 'TV',
                '„É©„Ç∏„Ç™': 'radio',
                '„Ç´„É°„É©': 'camera',
                '„Éó„É™„É≥„Çø„Éº': 'printer',
                '„Ç≠„Éº„Éú„Éº„Éâ': 'keyboard',
                '„Éû„Ç¶„Çπ': 'mouse',
                '„Çπ„ÇØ„É™„Éº„É≥': 'screen',
                '„É¢„Éã„Çø„Éº': 'monitor',
                '„Çπ„Éî„Éº„Ç´„Éº': 'speaker',
                '„Éò„ÉÉ„Éâ„Éï„Ç©„É≥': 'headphones',
                '„Éû„Ç§„ÇØ': 'microphone',
                '„Éï„Ç°„Ç§„É´': 'file',
                '„Éï„Ç©„É´„ÉÄ„Éº': 'folder',
                '„Éá„Éº„Çø': 'data',
                '„ÇΩ„Éï„Éà„Ç¶„Çß„Ç¢': 'software',
                '„Éè„Éº„Éâ„Ç¶„Çß„Ç¢': 'hardware',
                '„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ': 'network',
                '„Ç∑„Çπ„ÉÜ„É†': 'system',
                '„Éó„É≠„Ç∞„É©„É†': 'program',
                '„Ç¢„ÉÉ„Éó„Éá„Éº„Éà': 'update',
                '„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ': 'download',
                '„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ': 'upload'
            };
            
            return katakanaToEnglish[katakana] || katakana.toLowerCase();
        }
        
        // Êó•Êú¨Ë™û„ÅÆÊï∞Â≠ó„ÇíËã±Ë™û„Å´Â§âÊèõ
        function convertJapaneseNumbers(japanese) {
            const numberMap = {
                '‰∏Ä': '1', '‰∫å': '2', '‰∏â': '3', 'Âõõ': '4', '‰∫î': '5',
                'ÂÖ≠': '6', '‰∏É': '7', 'ÂÖ´': '8', '‰πù': '9', 'ÂçÅ': '10',
                'Áôæ': '100', 'ÂçÉ': '1000', '‰∏á': '10000'
            };
            
            // Á∞°Âçò„Å™Êï∞Â≠óÂ§âÊèõÔºàÂÆåÂÖ®„Å™Â§âÊèõ„ÅØË§áÈõë„Å™„ÅÆ„ÅßÂü∫Êú¨ÁöÑ„Å™„ÇÇ„ÅÆ„ÅÆ„ÅøÔºâ
            for (const [jp, en] of Object.entries(numberMap)) {
                if (japanese === jp) {
                    return en;
                }
            }
            
            return japanese;
        }
        
        // ÊÆã„Å£„ÅüÊó•Êú¨Ë™û„ÇíÂá¶ÁêÜ
        function handleRemainingJapanese(translation, originalText) {
            // Êó•Êú¨Ë™û„ÅåÊÆã„Å£„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆÂá¶ÁêÜ
            return translation.replace(/[„ÅÇ-„Çñ„Ç¢-„É∂‰∏Ä-ÈæØ„ÄÅ„ÄÇ„Äå„Äç]+/g, (match) => {
                // Áü≠„ÅÑÂçòË™û„ÅØ„Åù„ÅÆ„Åæ„Åæ„ÄÅÈï∑„ÅÑÊñáÁ´†„ÅØÁ∞°ÊΩî„Å´Ë°®Á§∫
                if (match.length <= 3) {
                    return `(${match})`; // Áü≠„ÅÑÂ†¥Âêà„ÅØÊã¨Âºß„ÅßÂõ≤„ÇÄ
                } else {
                    return `"${match}"`; // Èï∑„ÅÑÂ†¥Âêà„ÅØÂºïÁî®Á¨¶„ÅßÂõ≤„ÇÄ
                }
            });
        }
        
        // ÁøªË®≥ÁµêÊûú„ÇíÊúÄÁµÇË™øÊï¥
        function finalizeTranslation(translation, originalText, hasTranslation) {
            // Ëã±Ë™û„Çâ„Åó„ÅÑÊï¥ÂΩ¢
            translation = translation
                .replace(/\s+/g, ' ')  // Ë§áÊï∞„ÅÆ„Çπ„Éö„Éº„Çπ„Çí‰∏Ä„Å§„Å´
                .replace(/^[a-z]/, (match) => match.toUpperCase())  // ÊúÄÂàù„ÅÆÊñáÂ≠ó„ÇíÂ§ßÊñáÂ≠ó„Å´
                .trim();
            
            // ÁøªË®≥„Åå„Åß„Åç„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
            if (!hasTranslation && translation === originalText) {
                // Á∞°Âçò„Å™Èü≥ÂÜô„ÇíË©¶„Åø„Çã
                const phoneticTranslation = createPhoneticTranslation(originalText);
                if (phoneticTranslation !== originalText) {
                    return phoneticTranslation;
                }
                
                // ÊúÄÁµÇÁöÑ„Å´„ÄåÊó•Êú¨Ë™û„Äç„Å®„Åó„Å¶Ë°®Á§∫
                return `"${originalText}" (Japanese)`;
            }
            
            return translation || `"${originalText}"`;
        }
        
        // Á∞°Âçò„Å™Èü≥ÂÜôÂ§âÊèõÔºàÈôêÂÆöÁöÑÔºâ
        function createPhoneticTranslation(text) {
            // „Çà„Åè‰Ωø„Çè„Çå„ÇãÊó•Êú¨Ë™û„ÅÆÈü≥ÂÜô
            const phoneticMap = {
                '„ÅÇ„Çä„Åå„Å®„ÅÜ': 'arigatou',
                '„Åô„Åø„Åæ„Åõ„Çì': 'sumimasen',
                '„Åï„Çà„ÅÜ„Å™„Çâ': 'sayounara',
                '„Åì„Çì„Å´„Å°„ÅØ': 'konnichiwa',
                '„Åä„ÅØ„Çà„ÅÜ': 'ohayou',
                '„Åì„Çì„Å∞„Çì„ÅØ': 'konbanwa'
            };
            
            for (const [japanese, romaji] of Object.entries(phoneticMap)) {
                if (text.includes(japanese)) {
                    return text.replace(japanese, romaji);
                }
            }
            
            return text;
        }
        
        // Âü∫Êú¨ÁöÑ„Å™Êó•Êú¨Ë™ûÊñáÊßãÈÄ†„ÅÆÁøªË®≥ÔºàÊã°ÂºµÁâàÔºâ
        function basicJapaneseTranslation(text) {
            // Âü∫Êú¨„Éë„Çø„Éº„É≥„ÅÆÁøªË®≥
            const basicPatterns = [
                // Â•Ω„ÅçÂ´å„ÅÑ„ÅÆË°®Áèæ
                { pattern: /(.+)„ÅåÂ•Ω„Åç„Åß„Åô/, replacement: 'I like $1' },
                { pattern: /(.+)„ÅåÂ´å„ÅÑ„Åß„Åô/, replacement: 'I dislike $1' },
                { pattern: /(.+)„ÅåÂ•Ω„Åç/, replacement: 'I like $1' },
                { pattern: /(.+)„ÅåÂ´å„ÅÑ/, replacement: 'I dislike $1' },
                
                // È£ü‰∫ãÈñ¢ÈÄ£
                { pattern: /(.+)„ÇíÈ£ü„Åπ„Åæ„Åó„Åü/, replacement: 'I ate $1' },
                { pattern: /(.+)„ÇíÈ£≤„Åø„Åæ„Åó„Åü/, replacement: 'I drank $1' },
                { pattern: /(.+)„ÇíÈ£ü„Åπ„Çã/, replacement: 'eat $1' },
                { pattern: /(.+)„ÇíÈ£≤„ÇÄ/, replacement: 'drink $1' },
                { pattern: /(.+)„Çí‰Ωú„Çä„Åæ„Åó„Åü/, replacement: 'I made $1' },
                { pattern: /(.+)„Çí‰Ωú„Çã/, replacement: 'make $1' },
                
                // ÁßªÂãïÈñ¢ÈÄ£
                { pattern: /(.+)„Å´Ë°å„Åç„Åæ„Åó„Åü/, replacement: 'I went to $1' },
                { pattern: /(.+)„Åã„ÇâÊù•„Åæ„Åó„Åü/, replacement: 'I came from $1' },
                { pattern: /(.+)„Å´Ë°å„Åè/, replacement: 'go to $1' },
                { pattern: /(.+)„Åã„ÇâÊù•„Çã/, replacement: 'come from $1' },
                { pattern: /(.+)„Å´Â∏∞„Çä„Åæ„Åó„Åü/, replacement: 'I returned to $1' },
                { pattern: /(.+)„Å´Â∏∞„Çã/, replacement: 'return to $1' },
                
                // Â≠òÂú®Ë°®Áèæ
                { pattern: /(.+)„Åå„ÅÑ„Åæ„Åô/, replacement: 'There is $1' },
                { pattern: /(.+)„Åå„ÅÇ„Çä„Åæ„Åô/, replacement: 'There is $1' },
                { pattern: /(.+)„Åå„ÅÑ„Çã/, replacement: 'There is $1' },
                { pattern: /(.+)„Åå„ÅÇ„Çã/, replacement: 'There is $1' },
                
                // Áä∂ÊÖãË°®Áèæ
                { pattern: /(.+)„Åß„Åó„Åü/, replacement: 'It was $1' },
                { pattern: /(.+)„Åß„Åô/, replacement: 'It is $1' },
                { pattern: /(.+)„Å†„Å£„Åü/, replacement: 'It was $1' },
                { pattern: /(.+)„Å†/, replacement: 'It is $1' },
                
                // Ë≥™ÂïèË°®Áèæ
                { pattern: /(.+)„Åß„Åô„Åã/, replacement: 'Is it $1?' },
                { pattern: /(.+)„Åæ„Åó„Åü„Åã/, replacement: 'Did you $1?' },
                { pattern: /(.+)„Åæ„Åô„Åã/, replacement: 'Will you $1?' },
                { pattern: /(.+)„Åß„Åô„ÅãÔºü/, replacement: 'Is it $1?' },
                
                // Êú™Êù•Ë°®Áèæ
                { pattern: /(.+)„Åó„Åæ„Åô/, replacement: 'I will $1' },
                { pattern: /(.+)„Åô„Çã„Å§„ÇÇ„Çä„Åß„Åô/, replacement: 'I plan to $1' },
                { pattern: /(.+)„Åô„Çã‰∫àÂÆö„Åß„Åô/, replacement: 'I plan to $1' },
                
                // ÈÄ≤Ë°åÂΩ¢
                { pattern: /(.+)„Åó„Å¶„ÅÑ„Åæ„Åô/, replacement: 'I am $1 ing' },
                { pattern: /(.+)„Åó„Å¶„ÅÑ„Çã/, replacement: 'I am $1 ing' },
                { pattern: /(.+)„Åó„Å¶„ÅÑ„Åæ„Åó„Åü/, replacement: 'I was $1 ing' },
                
                // ËÉΩÂäõË°®Áèæ
                { pattern: /(.+)„Åß„Åç„Åæ„Åô/, replacement: 'I can $1' },
                { pattern: /(.+)„Åß„Åç„Çã/, replacement: 'can $1' },
                { pattern: /(.+)„Åß„Åç„Åæ„Åõ„Çì/, replacement: 'I cannot $1' },
                { pattern: /(.+)„Åß„Åç„Å™„ÅÑ/, replacement: 'cannot $1' },
                
                // Â∏åÊúõË°®Áèæ
                { pattern: /(.+)„Åü„ÅÑ„Åß„Åô/, replacement: 'I want to $1' },
                { pattern: /(.+)„Åü„ÅÑ/, replacement: 'want to $1' },
                { pattern: /(.+)„ÅåÊ¨≤„Åó„ÅÑ„Åß„Åô/, replacement: 'I want $1' },
                { pattern: /(.+)„ÅåÊ¨≤„Åó„ÅÑ/, replacement: 'want $1' },
                
                // ÁµåÈ®ìË°®Áèæ
                { pattern: /(.+)„Åó„Åü„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô/, replacement: 'I have $1 before' },
                { pattern: /(.+)„Åó„Åü„Åì„Å®„Åå„Å™„ÅÑ/, replacement: 'I have never $1' },
                
                // Áæ©ÂãôË°®Áèæ
                { pattern: /(.+)„Å™„Åë„Çå„Å∞„ÅÑ„Åë„Åæ„Åõ„Çì/, replacement: 'I must $1' },
                { pattern: /(.+)„Å™„Åë„Çå„Å∞„Å™„Çâ„Å™„ÅÑ/, replacement: 'I must $1' },
                { pattern: /(.+)„Åπ„Åç„Åß„Åô/, replacement: 'should $1' },
                
                // ÊñπÊ≥ïË°®Áèæ
                { pattern: /(.+)„Åß(.+)„Åó„Åæ„Åô/, replacement: '$1 $2 by $1' },
                { pattern: /(.+)„Çí‰Ωø„Å£„Å¶(.+)/, replacement: '$2 using $1' },
                
                // ÊôÇÈñì3Ë°®Áèæ
                { pattern: /(.+)„ÅÆÊôÇ„Å´(.+)/, replacement: '$2 when $1' },
                { pattern: /(.+)„ÅÆÂæå„Åß(.+)/, replacement: '$2 after $1' },
                { pattern: /(.+)„ÅÆÂâç„Å´(.+)/, replacement: '$2 before $1' }
            ];
            
            for (const pattern of basicPatterns) {
                if (pattern.pattern.test(text)) {
                    return text.replace(pattern.pattern, pattern.replacement);
                }
            }
            
            return text;
        }

        async function startRecognition() {
            // „Äå„É¶„Éº„Ç∂„Éº„ÅåÁ∂ôÁ∂ö„ÇíÂ∏åÊúõ„Äç„Åó„Å¶„ÅÑ„ÇãÁä∂ÊÖã„Å®„Åó„Å¶ÂÖà„Å´Á´ã„Å¶„Çã
            isRecognizing = true;

            // ÈÅ∏Êäû„Åï„Çå„Åü„Éû„Ç§„ÇØ„ÇíÂèñÂæó
            const micReady = await getSelectedMicrophone(true);
            if (!micReady) {
                isRecognizing = false;
                return;
            }

            if (!recognition && !initializeSpeechRecognition()) {
                return;
            }

            recognition.lang = document.getElementById('languageSelect').value;
            
            try {
                if (recognitionIsActive || recognitionStartPending) {
                    updateStatus('üé§ Already listening');
                    return;
                }

                // „É¶„Éº„Ç∂„ÉºÊìç‰Ωú„Åå„ÅÇ„Çå„Å∞AudioContext„ÇíÊúâÂäπÂåñ„Åó„Å¶keep-alive„ÇíÊé•Á∂ö
                const ctx = ensureAudioContext();
                if (ctx && ctx.state === 'suspended') {
                    try { await ctx.resume(); } catch {}
                }
                tryConnectMicKeepAlive();

                recognitionStartPending = true;
                recognition.start();
            } catch (e) {
                console.error('ÈñãÂßã„Ç®„É©„Éº:', e);
                updateStatus('Failed to start');
                recognitionStartPending = false;
                isRecognizing = false;
            }
        }

        function stopRecognition() {
            isRecognizing = false;
            autoStarted = false;
            recognitionStartPending = false;
            resetRecognitionRestartBackoff();
            document.getElementById('recordingIndicator').style.display = 'none';

            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.error('ÂÅúÊ≠¢„Ç®„É©„Éº:', e);
                }
            }

            updateStatus('‚èπÔ∏è Stopped');

            const startBtn = document.getElementById('startButton');
            const stopBtn = document.getElementById('stopButton');
            if (startBtn) startBtn.disabled = false;
            if (stopBtn) stopBtn.disabled = true;
        }

        function resetRecognition() {
            updateStatus('üîÑ Restarting recognition...');
            // Ëá™ÂãïÂÜçÈñã„ÅÆ„Åü„ÇÅ„ÄÅ„Éú„Çø„É≥Áä∂ÊÖã„ÅÆÂ§âÊõ¥„ÅØ‰∏çË¶Å
        }

        async function translateWithGoogle(text, targetLang = 'en') {
            const apiKey = document.getElementById('apiKeyInput')?.value?.trim() || '';

            if (!apiKey) {
                return await translateOfflineUnified(text, targetLang);
            }

            try {
                const response = await fetch(`https://translation.googleapis.com/language/translate/v2?key=${encodeURIComponent(apiKey)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        q: text,
                        target: targetLang,
                        format: 'text'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();
                return data?.data?.translations?.[0]?.translatedText || '(untranslated)';
            } catch (error) {
                console.error('GoogleÁøªË®≥„Ç®„É©„Éº:', error);
                updateStatus(`Translation error: ${error.message || error}`);
                return await translateOfflineUnified(text, targetLang);
            }
        }

        async function translateOfflineUnified(text, targetLang = 'en') {
            const sourceLang = (document.getElementById('languageSelect')?.value || 'ja-JP').split('-')[0];

            // ÊúüÂæÖÂÄ§: Êó•Êú¨Ë™ûÈü≥Â£∞ ‚Üí Ëã±Ë™ûË°®Á§∫
            if (sourceLang === 'ja' && targetLang === 'en') {
                return translateJapaneseToEnglish(text);
            }

            // „Åù„ÅÆ‰ªñË®ÄË™û„ÅØ„Ç™„Éï„É©„Ç§„É≥„Åß„ÅØÈôêÂÆöÁöÑ„Å™„ÅÆ„Åß„ÄÅÊúÄ‰ΩéÈôê„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
            return '(untranslated)';
        }

        async function translateUnified(text) {
            const autoTranslate = document.getElementById('autoTranslate')?.checked;
            if (!autoTranslate) {
                return '';
            }

            const targetLang = document.getElementById('targetLanguageSelect')?.value || 'en';
            return await translateWithGoogle(text, targetLang);
        }

        async function testApiKey() {
            const apiKey = document.getElementById('apiKeyInput')?.value?.trim() || '';
            if (!apiKey) {
                updateStatus('Please enter an API key');
                return;
            }

            updateStatus('Testing API key...');

            try {
                const translated = await translateWithGoogle('Hello', 'ja');
                if (translated && translated.toLowerCase() !== 'hello') {
                    updateStatus('‚úÖ API key is valid');
                } else {
                    updateStatus('‚ö†Ô∏è API key does not seem to work');
                }
            } catch (e) {
                updateStatus('‚ùå Failed to test API key');
            }
        }

        async function displaySubtitles(text, isInterim = false, confidence = 0.5) {
            const container = document.getElementById('subtitleContainer');
            const jpSubtitle = document.getElementById('subtitleJp');
            const enSubtitle = document.getElementById('subtitleEn');
            const translationIndicator = document.getElementById('translationIndicator');
            const confidenceBar = document.getElementById('confidenceBar');
            const showJp = document.getElementById('showJapanese').checked;
            const showEn = document.getElementById('showEnglish').checked;
            const autoTranslate = document.getElementById('autoTranslate')?.checked;

            // ‰ø°È†ºÂ∫¶„Éê„Éº
            if (confidenceBar) {
                const clamped = Math.max(0, Math.min(1, Number(confidence) || 0));
                confidenceBar.style.width = (clamped * 100) + '%';
            }

            if (showJp) {
                jpSubtitle.textContent = text;
                jpSubtitle.className = isInterim ? 'subtitle-jp interim' : 'subtitle-jp final';
                jpSubtitle.style.display = 'block';
            } else {
                jpSubtitle.style.display = 'none';
            }

            if (showEn && autoTranslate && !isInterim) {
                if (translationIndicator) translationIndicator.classList.remove('hidden');

                const seq = ++translationRequestSeq;
                const translated = await translateUnified(text);
                if (seq !== translationRequestSeq) {
                    return; // Âè§„ÅÑÁµêÊûú„ÅØÊç®„Å¶„Çã
                }

                enSubtitle.textContent = translated;
                enSubtitle.style.display = 'block';

                if (translationIndicator) translationIndicator.classList.add('hidden');
            } else {
                enSubtitle.style.display = 'none';
                if (translationIndicator) translationIndicator.classList.add('hidden');
            }

            container.style.display = 'block';
            container.classList.remove('hidden');

            // Ëá™ÂãïÈùûË°®Á§∫„ÅÆ„Çø„Ç§„Éû„Éº
            if (!isInterim) {
                clearTimeout(hideTimeout);
                const duration = parseInt(document.getElementById('maxDurationRange').value) * 1000;
                hideTimeout = setTimeout(hideSubtitles, duration);
            }
        }

        function hideSubtitles() {
            document.getElementById('subtitleContainer').style.display = 'none';
            document.getElementById('translationIndicator')?.classList.add('hidden');
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function toggleControls() {
            document.body.classList.toggle('hide-controls');
        }

        // „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÅÆË™øÊï¥
        document.getElementById('fontSizeRange').addEventListener('input', (e) => {
            const size = e.target.value;
            document.querySelector('.subtitle-jp').style.fontSize = size + 'px';
            document.querySelector('.subtitle-en').style.fontSize = (size * 0.85) + 'px';
        });

        // „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆÂ§âÊõ¥ÊôÇ
        document.getElementById('showJapanese').addEventListener('change', () => {
            if (currentTranscript) {
                displaySubtitles(currentTranscript);
            }
        });

        document.getElementById('showEnglish').addEventListener('change', () => {
            if (currentTranscript) {
                displaySubtitles(currentTranscript);
            }
        });

        document.getElementById('autoTranslate').addEventListener('change', () => {
            if (currentTranscript) {
                displaySubtitles(currentTranscript);
            }
        });

        // Ë®ÄË™ûÂ§âÊõ¥ÊôÇ
        document.getElementById('languageSelect').addEventListener('change', () => {
            if (isRecognizing) {
                stopRecognition();
                setTimeout(startRecognition, 100);
            }
        });

        // „Éû„Ç§„ÇØÂ§âÊõ¥ÊôÇ
        document.getElementById('microphoneSelect').addEventListener('change', async () => {
            if (isRecognizing) {
                isRecognizing = false;
                if (recognition) {
                    recognition.stop();
                }
                // Â∞ë„ÅóÂæÖ„Å£„Å¶„Åã„ÇâÊñ∞„Åó„ÅÑ„Éû„Ç§„ÇØ„ÅßÂÜçÈñã
                setTimeout(async () => {
                    autoStarted = false;
                    await autoStartRecognition();
                }, 500);
            } else {
                // Ë™çË≠ò‰∏≠„Åß„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ„Éû„Ç§„ÇØ„ÅÆÊ∫ñÂÇô„Å†„ÅëË°å„ÅÜ
                await getSelectedMicrophone(true);
            }
        });

        // Ë°®Á§∫ÁØÑÂõ≤„Ç¨„Ç§„Éâ„ÅÆÂàá„ÇäÊõø„Åà
        document.getElementById('showDisplayGuide').addEventListener('change', (e) => {
            const guide = document.getElementById('displayGuide');
            if (e.target.checked) {
                guide.classList.add('show');
            } else {
                guide.classList.remove('show');
            }
        });

        // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === ' ') {
                e.preventDefault();
                if (isRecognizing) {
                    stopRecognition();
                } else {
                    startRecognition();
                }
            } else if (e.ctrlKey && e.key === 'h') {
                e.preventDefault();
                toggleControls();
            }
        });

        // „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊôÇ„ÅÆÂàùÊúüÂåñ
        window.addEventListener('load', async () => {
            // Â≠¶Áøí„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø
            loadLearningData();

            // API„Ç≠„Éº„ÇíÂæ©ÂÖÉ
            const savedApiKey = localStorage.getItem('googleTranslateApiKey');
            if (savedApiKey) {
                const input = document.getElementById('apiKeyInput');
                if (input) input.value = savedApiKey;
            }

            // API„Ç≠„Éº„Çí‰øùÂ≠ò
            const apiKeyInput = document.getElementById('apiKeyInput');
            if (apiKeyInput) {
                apiKeyInput.addEventListener('change', (e) => {
                    localStorage.setItem('googleTranslateApiKey', e.target.value || '');
                });
            }

            // „É¶„Éº„Ç∂„ÉºÊìç‰Ωú„ÅåÂÖ•„Å£„Åü„Çâ AudioContext „ÇíÊúâÂäπÂåñÔºàkeep-aliveÁî®Ôºâ
            document.addEventListener('pointerdown', async () => {
                const ctx = ensureAudioContext();
                if (ctx && ctx.state === 'suspended') {
                    try { await ctx.resume(); } catch {}
                }
                tryConnectMicKeepAlive();
            }, { once: true });
            
            initializeSpeechRecognition();
            await enumerateMicrophones();
            updateStatus('‚úÖ Ready (press ‚ÄúStart‚Äù if needed)');

            startMicWatchdog();
            
            // Ëá™Âãï„ÅßÈü≥Â£∞Ë™çË≠ò„ÇíÈñãÂßã
            setTimeout(autoStartRecognition, 1000);
        });

        // „Éö„Éº„Ç∏„ÇíÈõ¢„Çå„ÇãÊôÇ„ÅÆÂá¶ÁêÜ
        window.addEventListener('beforeunload', () => {
            isRecognizing = false;
            if (recognition) {
                recognition.stop();
            }

            if (micWatchdogTimer) {
                clearInterval(micWatchdogTimer);
                micWatchdogTimer = null;
            }
            
            // „É°„Éá„Ç£„Ç¢„Çπ„Éà„É™„Éº„É†„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }

            if (audioContext) {
                try { audioContext.close(); } catch {}
                audioContext = null;
            }
        });
    </script>
</body>
</html>